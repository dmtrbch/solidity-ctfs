# Shop

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface Buyer {
  function price() external view returns (uint);
}

contract Shop {
  uint public price = 100;
  bool public isSold;

  function buy() public {
    Buyer _buyer = Buyer(msg.sender);

    if (_buyer.price() >= price && !isSold) {
      isSold = true;
      price = _buyer.price();
    }
  }
}
```

## Goal

Buy the item from the shop for less than 100, make the value of the price variable inside Shop to be less than 100

## Exploit

For this exercise we are starting with some inital balance of Naught Coins in our account and we need to find a way how to transfer them to another account and not waiting for the deadline to expire.

If we take a look at the transfer() function inside NaughtCoin contract we notice that this function has a modifier attached to it (lockTokens) that does not allow us to transfer the tokens if the current block timestamp is not greater than the timelock. But there is something strange here, inside the modifier we check if the msg.sender is the player. The question that arises is, what if someone else can transfer our tokens on our behalf, is that possible?

In order to solve this CTF, one must be familiar with the <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc20" target="_blank" rel="noopener noreferrer">ERC20 specification</a> from OpenZeppelin. After some research, I found out that there is another function transferFrom inside the ERC20 specification, that can be used for transferring tokens from one to another address. This function allows us to transfer someone else's tokens on their behalf to another address. There is one thing that we should take in mind, the owner of the tokens should approve us to transfer the tokens on their behalf.

Since the Naught Coin is inheriting from the ERC20 standard, we can use the above-mentioned approach to solve this CTF

The steps to reproduce the exploit would be:

1. create Attacker contract, and create instance from the NaughtCoin contract inside the Attacker contract
2. call the approve function from the NaughtCoin contract (contract.approve), with the address of the Attacker contract as first parameter, and the amount we want to approve as second (in our case it will be balanceOf(msg.sender))
3. create withdrawFunds() external function, and inside this function call the transferFrom(from, to, amount) function from the NaughtCoin contract
  - our account address should be used for the from parameter</li>
  - the address of the Attacker contract should be used for the to parameter</li>
  - naughtCoin.balanceOf(msg.sender) should be used for the amount parameter</li>

4. call the withdrawFunds function() from our account

## Attacker contract code

```
contract Attacker {
  NaughtCoin private immutable coin;

  constructor(NaughtCoin _coin) {
    coin = NaughtCoin(_coin);
  }

  function withdrawFunds() external {
    coin.transferFrom(msg.sender, address(this), coin.balanceOf(msg.sender));
  }
}
```